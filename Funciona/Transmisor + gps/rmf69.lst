CCS PCH C Compiler, Version 5.059, 5967               13-may.-17 15:29

               Filename:   C:\Users\Jesus\Desktop\TESIS\Funciona\Transmisor + gps\rmf69.lst

               ROM used:   2628 bytes (8%)
                           Largest free fragment is 30140
               RAM used:   240 (12%) at main() level
                           276 (13%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   0944
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00FA
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0174
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
*
010A:  BCF    F9E.0
010C:  GOTO   006C
.................... #device PIC18F4550 
*
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 01,04
00CC:  DATA 02,00
00CE:  DATA 03,02
00D0:  DATA 04,40
00D2:  DATA 05,03
00D4:  DATA 06,33
00D6:  DATA 07,E4
00D8:  DATA 08,C0
00DA:  DATA 09,00
00DC:  DATA 19,42
00DE:  DATA 25,40
00E0:  DATA 26,07
00E2:  DATA 28,10
00E4:  DATA 29,DC
00E6:  DATA 2D,03
00E8:  DATA 2E,88
00EA:  DATA 2F,2D
00EC:  DATA 30,01
00EE:  DATA 37,90
00F0:  DATA 38,42
00F2:  DATA 3C,8F
00F4:  DATA 3D,12
00F6:  DATA 6F,30
00F8:  DATA FF,00
00FA:  MOVLW  01
00FC:  ADDWF  20,F
00FE:  BTFSC  FD8.0
0100:  INCF   21,F
0102:  BTFSC  FD8.2
0104:  INCF   22,F
0106:  BTFSC  FD8.2
0108:  INCF   23,F
*
06C2:  MOVFF  EE,FEA
06C6:  MOVFF  ED,FE9
06CA:  MOVFF  F1,FEF
06CE:  INCF   FE9,F
06D0:  BTFSC  FD8.2
06D2:  INCF   FEA,F
06D4:  CLRF   FEF
06D6:  INCF   xED,F
06D8:  BTFSC  FD8.2
06DA:  INCF   xEE,F
06DC:  GOTO   06F2 (RETURN)
06E0:  MOVF   FEF,F
06E2:  BZ    0702
06E4:  MOVFF  FEA,F0
06E8:  MOVFF  FE9,EF
06EC:  MOVFF  FEF,F1
06F0:  BRA    06C2
06F2:  MOVFF  F0,FEA
06F6:  MOVFF  EF,FE9
06FA:  INCF   FE9,F
06FC:  BTFSC  FD8.2
06FE:  INCF   FEA,F
0700:  BRA    06E0
0702:  GOTO   0A10 (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #Fuses HS, nowdt, nolvp, novregen, noprotect, nomclr, noPUT, nobrownout 
.................... #use delay(clock=20M, crystal=20M) // a 3.3V se transforma en ~3MHZ 
*
065C:  CLRF   FEA
065E:  MOVLW  F0
0660:  MOVWF  FE9
0662:  MOVF   FEF,W
0664:  BZ    0680
0666:  MOVLW  06
0668:  MOVWF  01
066A:  CLRF   00
066C:  DECFSZ 00,F
066E:  BRA    066C
0670:  DECFSZ 01,F
0672:  BRA    066A
0674:  MOVLW  7B
0676:  MOVWF  00
0678:  DECFSZ 00,F
067A:  BRA    0678
067C:  DECFSZ FEF,F
067E:  BRA    0666
0680:  RETURN 0
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=GPS,errors) 
*
0110:  BTFSS  F9E.5
0112:  BRA    0110
0114:  MOVFF  FAB,1F
0118:  MOVFF  FAE,01
011C:  BTFSS  1F.1
011E:  BRA    0124
0120:  BCF    FAB.4
0122:  BSF    FAB.4
0124:  GOTO   0176 (RETURN)
.................... #USE TIMER(TIMER=1,TICK=1ms,BITS=32,ISR) 
*
01EA:  MOVFF  20,01
01EE:  MOVF   FCE,W
01F0:  MOVFF  FCF,03
01F4:  BCF    F9D.0
01F6:  MOVWF  02
01F8:  MOVF   20,W
01FA:  SUBWF  01,W
01FC:  BZ    0206
01FE:  MOVF   FCE,W
0200:  MOVFF  FCF,03
0204:  BRA    0208
0206:  MOVF   02,W
0208:  MOVFF  03,00
020C:  MOVFF  20,01
0210:  MOVFF  21,02
0214:  MOVFF  22,03
0218:  MOVF   23,W
021A:  RRCF   FE8,F
021C:  RRCF   03,F
021E:  RRCF   02,F
0220:  RRCF   01,F
0222:  RRCF   00,F
0224:  BSF    F9D.0
0226:  GOTO   0006 (RETURN)
....................  
.................... //----------------------------------------- 
.................... //Definicion pines RFM69 
.................... #define _slaveSelectPin Pin_D7 
.................... #define SCK             Pin_D6 
.................... #define SerOut          Pin_D5 
.................... #define SerIn           Pin_D4 
.................... #define _interruptPin   Pin_B0 
.................... #define GPSPower        Pin_D2 
....................  
....................   
....................  
.................... //----------------------------------------- 
.................... #include "GPS.c"  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... #include <string.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... typedef struct _DateTimeInfo  
.................... {  
....................    int8 Day;  
....................    int8 Month;  
....................    int8 Year;  
....................    int8 Hour;  
....................    int8 Minute;  
....................    int8 Second;  
.................... } DateTimeInfo;  
.................... ////////////////////////////////////////  
.................... typedef struct _GPRMCInfo  
.................... {  
....................    char Valid;  
....................    DateTimeInfo DT;  
....................    float Latitude;  
....................    char N_S;  
....................    float Longitude;  
....................    char E_W;  
....................    float Speed;  
.................... } GPRMCInfo;  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... //copy string (pos n to pos m) from s2 to s1  
.................... char* StrnmCpy(char *s1, char *s2, size_t n, size_t m)  
.................... {  
....................    int8 i;  
....................    char *s;  
....................      
....................    for (s=s1, i=n, s2+=n; i<=m; i++)  
....................       *s++ = *s2++;  
....................    *s = '\0';  
....................      
....................    return s1;  
.................... }  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... // find c in s starting from pos st  
.................... int8 StrFnd(char *s, char c, size_t st)  
.................... {  
....................    int8 l;  
....................      
....................    for (l=st, s+=st ; *s != '\0' ; l++, s++)  
*
0128:  MOVFF  110,112
012C:  MOVLB  1
012E:  MOVF   x10,W
0130:  ADDWF  x0D,F
0132:  MOVF   x11,W
0134:  ADDWFC x0E,F
0136:  MOVFF  10E,03
013A:  MOVFF  10D,FE9
013E:  MOVFF  10E,FEA
0142:  MOVF   FEF,F
0144:  BZ    016A
....................       if (*s == c)  
0146:  MOVFF  10E,03
014A:  MOVFF  10D,FE9
014E:  MOVFF  10E,FEA
0152:  MOVF   x0F,W
0154:  SUBWF  FEF,W
0156:  BNZ   015E
....................          return l;  
0158:  MOVFF  112,01
015C:  BRA    016E
015E:  MOVF   x12,W
0160:  INCF   x12,F
0162:  INCF   x0D,F
0164:  BTFSC  FD8.2
0166:  INCF   x0E,F
0168:  BRA    0136
....................    return -1;  
016A:  MOVLW  FF
016C:  MOVWF  01
016E:  MOVLB  0
0170:  GOTO   01A0 (RETURN)
.................... }  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... void GPRMC_decode(char *GPRMCStr, GPRMCInfo *RMCInfo)  
.................... {  
....................    int8 p1, p2;  
....................    char TempStr[16];  
....................      
....................    p1 = StrFnd(GPRMCStr, ',', 0);      //find first comma  
....................    if (p1 == 6)  
....................    {  
....................       //check for valid packet:  
....................       if ( (StrFnd(GPRMCStr, 'A', 0) == 17) && (GPRMCStr[0]=='$')) //valid?  
....................       { 
....................          RMCInfo->Valid = 'A';  
....................            
....................          //Get time  
....................          p1 = StrFnd(GPRMCStr, ',', 0);      //find first comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->DT.Hour = atoi(StrnmCpy(TempStr, GPRMCStr, p1+1, p1+2));   //hour  
....................          RMCInfo->DT.Minute = atoi(StrnmCpy(TempStr, GPRMCStr, p1+3, p1+4)); //min  
....................          RMCInfo->DT.Second = atoi(StrnmCpy(TempStr, GPRMCStr, p1+5, p1+6)); //sec  
....................            
....................          //Get latitude & direction  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->Latitude = atof(StrnmCpy(TempStr, GPRMCStr, p1+1, p2-1));  
....................          RMCInfo->N_S = GPRMCStr[p2+1];  
....................            
....................          //Get longitude & direction  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->Longitude = atof(StrnmCpy(TempStr, GPRMCStr, p1+1, p2-1));  
....................          RMCInfo->E_W = GPRMCStr[p2+1];  
....................            
....................          //Get speed  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->Speed = atof(StrnmCpy(TempStr, GPRMCStr, p1+1, p2-1));  
....................            
....................          //Get date  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->DT.Day = atoi(StrnmCpy(TempStr, GPRMCStr, p1+1, p1+2));  //dd  
....................          RMCInfo->DT.Month = atoi(StrnmCpy(TempStr, GPRMCStr, p1+3, p1+4));//mm  
....................          RMCInfo->DT.year = atoi(StrnmCpy(TempStr, GPRMCStr, p1+5, p1+6)); //yy  
....................       }  
....................       else                                //not valid  
....................       {  
....................          RMCInfo->Valid = 'V';  
....................       }  
....................    }  
.................... }  
....................  
.................... // ---------------------------------------- 
.................... #include "RFM69.h" 
.................... #include <RFM69registers.h> 
.................... // ********************************************************************************** 
.................... // Registers used in driver definition for HopeRF RFM69W/RFM69HW, Semtech SX1231/1231H 
.................... // ********************************************************************************** 
.................... // Copyright Felix Rusu (2015), felix@lowpowerlab.com 
.................... // http://lowpowerlab.com/ 
.................... // ********************************************************************************** 
.................... // License 
.................... // ********************************************************************************** 
.................... // This program is free software; you can redistribute it  
.................... // and/or modify it under the terms of the GNU General     
.................... // Public License as published by the Free Software        
.................... // Foundation; either version 2 of the License, or         
.................... // (at your option) any later version.                     
.................... //                                                         
.................... // This program is distributed in the hope that it will    
.................... // be useful, but WITHOUT ANY WARRANTY; without even the   
.................... // implied warranty of MERCHANTABILITY or FITNESS FOR A    
.................... // PARTICULAR PURPOSE.  See the GNU General Public         
.................... // License for more details.                               
.................... //                                                         
.................... // You should have received a copy of the GNU General     
.................... // Public License along with this program; if not, write  
.................... // to the Free Software Foundation, Inc.,                 
.................... // 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA 
.................... //                                                         
.................... // Licence can be viewed at                                
.................... // http://www.fsf.org/licenses/gpl.txt                     
.................... // 
.................... // Please maintain this license information along with authorship 
.................... // and copyright notices in any redistribution of this code 
.................... // ********************************************************************************** 
.................... // RFM69/SX1231 Internal registers addresses 
.................... //************************************************** 
.................... #define REG_FIFO          0x00 
.................... #define REG_OPMODE        0x01 
.................... #define REG_DATAMODUL     0x02 
.................... #define REG_BITRATEMSB    0x03 
.................... #define REG_BITRATELSB    0x04 
.................... #define REG_FDEVMSB       0x05 
.................... #define REG_FDEVLSB       0x06 
.................... #define REG_FRFMSB        0x07 
.................... #define REG_FRFMID        0x08 
.................... #define REG_FRFLSB        0x09 
.................... #define REG_OSC1          0x0A 
.................... #define REG_AFCCTRL       0x0B 
.................... #define REG_LOWBAT        0x0C 
.................... #define REG_LISTEN1       0x0D 
.................... #define REG_LISTEN2       0x0E 
.................... #define REG_LISTEN3       0x0F 
.................... #define REG_VERSION       0x10 
.................... #define REG_PALEVEL       0x11 
.................... #define REG_PARAMP        0x12 
.................... #define REG_OCP           0x13 
.................... #define REG_AGCREF        0x14  // not present on RFM69/SX1231 
.................... #define REG_AGCTHRESH1    0x15  // not present on RFM69/SX1231 
.................... #define REG_AGCTHRESH2    0x16  // not present on RFM69/SX1231 
.................... #define REG_AGCTHRESH3    0x17  // not present on RFM69/SX1231 
.................... #define REG_LNA           0x18 
.................... #define REG_RXBW          0x19 
.................... #define REG_AFCBW         0x1A 
.................... #define REG_OOKPEAK       0x1B 
.................... #define REG_OOKAVG        0x1C 
.................... #define REG_OOKFIX        0x1D 
.................... #define REG_AFCFEI        0x1E 
.................... #define REG_AFCMSB        0x1F 
.................... #define REG_AFCLSB        0x20 
.................... #define REG_FEIMSB        0x21 
.................... #define REG_FEILSB        0x22 
.................... #define REG_RSSICONFIG    0x23 
.................... #define REG_RSSIVALUE     0x24 
.................... #define REG_DIOMAPPING1   0x25 
.................... #define REG_DIOMAPPING2   0x26 
.................... #define REG_IRQFLAGS1     0x27 
.................... #define REG_IRQFLAGS2     0x28 
.................... #define REG_RSSITHRESH    0x29 
.................... #define REG_RXTIMEOUT1    0x2A 
.................... #define REG_RXTIMEOUT2    0x2B 
.................... #define REG_PREAMBLEMSB   0x2C 
.................... #define REG_PREAMBLELSB   0x2D 
.................... #define REG_SYNCCONFIG    0x2E 
.................... #define REG_SYNCVALUE1    0x2F 
.................... #define REG_SYNCVALUE2    0x30 
.................... #define REG_SYNCVALUE3    0x31 
.................... #define REG_SYNCVALUE4    0x32 
.................... #define REG_SYNCVALUE5    0x33 
.................... #define REG_SYNCVALUE6    0x34 
.................... #define REG_SYNCVALUE7    0x35 
.................... #define REG_SYNCVALUE8    0x36 
.................... #define REG_PACKETCONFIG1 0x37 
.................... #define REG_PAYLOADLENGTH 0x38 
.................... #define REG_NODEADRS      0x39 
.................... #define REG_BROADCASTADRS 0x3A 
.................... #define REG_AUTOMODES     0x3B 
.................... #define REG_FIFOTHRESH    0x3C 
.................... #define REG_PACKETCONFIG2 0x3D 
.................... #define REG_AESKEY1       0x3E 
.................... #define REG_AESKEY2       0x3F 
.................... #define REG_AESKEY3       0x40 
.................... #define REG_AESKEY4       0x41 
.................... #define REG_AESKEY5       0x42 
.................... #define REG_AESKEY6       0x43 
.................... #define REG_AESKEY7       0x44 
.................... #define REG_AESKEY8       0x45 
.................... #define REG_AESKEY9       0x46 
.................... #define REG_AESKEY10      0x47 
.................... #define REG_AESKEY11      0x48 
.................... #define REG_AESKEY12      0x49 
.................... #define REG_AESKEY13      0x4A 
.................... #define REG_AESKEY14      0x4B 
.................... #define REG_AESKEY15      0x4C 
.................... #define REG_AESKEY16      0x4D 
.................... #define REG_TEMP1         0x4E 
.................... #define REG_TEMP2         0x4F 
.................... #define REG_TESTLNA       0x58 
.................... #define REG_TESTPA1       0x5A  // only present on RFM69HW/SX1231H 
.................... #define REG_TESTPA2       0x5C  // only present on RFM69HW/SX1231H 
.................... #define REG_TESTDAGC      0x6F 
....................  
.................... //****************************************************** 
.................... // RF69/SX1231 bit control definition 
.................... //****************************************************** 
....................  
.................... // RegOpMode 
.................... #define RF_OPMODE_SEQUENCER_OFF       0x80 
.................... #define RF_OPMODE_SEQUENCER_ON        0x00  // Default 
....................  
.................... #define RF_OPMODE_LISTEN_ON           0x40 
.................... #define RF_OPMODE_LISTEN_OFF          0x00  // Default 
....................  
.................... #define RF_OPMODE_LISTENABORT         0x20 
....................  
.................... #define RF_OPMODE_SLEEP               0x00 
.................... #define RF_OPMODE_STANDBY             0x04  // Default 
.................... #define RF_OPMODE_SYNTHESIZER         0x08 
.................... #define RF_OPMODE_TRANSMITTER         0x0C 
.................... #define RF_OPMODE_RECEIVER            0x10 
....................  
....................  
.................... // RegDataModul 
.................... #define RF_DATAMODUL_DATAMODE_PACKET            0x00  // Default 
.................... #define RF_DATAMODUL_DATAMODE_CONTINUOUS        0x40 
.................... #define RF_DATAMODUL_DATAMODE_CONTINUOUSNOBSYNC 0x60 
....................  
.................... #define RF_DATAMODUL_MODULATIONTYPE_FSK         0x00  // Default 
.................... #define RF_DATAMODUL_MODULATIONTYPE_OOK         0x08 
....................  
.................... #define RF_DATAMODUL_MODULATIONSHAPING_00       0x00  // Default 
.................... #define RF_DATAMODUL_MODULATIONSHAPING_01       0x01 
.................... #define RF_DATAMODUL_MODULATIONSHAPING_10       0x02 
.................... #define RF_DATAMODUL_MODULATIONSHAPING_11       0x03 
....................  
....................  
.................... // RegBitRate (bits/sec) example bit rates 
.................... #define RF_BITRATEMSB_1200            0x68 
.................... #define RF_BITRATELSB_1200            0x2B 
.................... #define RF_BITRATEMSB_2400            0x34 
.................... #define RF_BITRATELSB_2400            0x15 
.................... #define RF_BITRATEMSB_4800            0x1A  // Default 
.................... #define RF_BITRATELSB_4800            0x0B  // Default 
.................... #define RF_BITRATEMSB_9600            0x0D 
.................... #define RF_BITRATELSB_9600            0x05 
.................... #define RF_BITRATEMSB_19200           0x06 
.................... #define RF_BITRATELSB_19200           0x83 
.................... #define RF_BITRATEMSB_38400           0x03 
.................... #define RF_BITRATELSB_38400           0x41 
....................  
.................... #define RF_BITRATEMSB_38323           0x03 
.................... #define RF_BITRATELSB_38323           0x43 
....................  
.................... #define RF_BITRATEMSB_34482           0x03 
.................... #define RF_BITRATELSB_34482           0xA0 
....................  
.................... #define RF_BITRATEMSB_76800           0x01 
.................... #define RF_BITRATELSB_76800           0xA1 
.................... #define RF_BITRATEMSB_153600          0x00 
.................... #define RF_BITRATELSB_153600          0xD0 
.................... #define RF_BITRATEMSB_57600           0x02 
.................... #define RF_BITRATELSB_57600           0x2C 
.................... #define RF_BITRATEMSB_115200          0x01 
.................... #define RF_BITRATELSB_115200          0x16 
.................... #define RF_BITRATEMSB_12500           0x0A 
.................... #define RF_BITRATELSB_12500           0x00 
.................... #define RF_BITRATEMSB_25000           0x05 
.................... #define RF_BITRATELSB_25000           0x00 
.................... #define RF_BITRATEMSB_50000           0x02 
.................... #define RF_BITRATELSB_50000           0x80 
.................... #define RF_BITRATEMSB_100000          0x01 
.................... #define RF_BITRATELSB_100000          0x40 
.................... #define RF_BITRATEMSB_150000          0x00 
.................... #define RF_BITRATELSB_150000          0xD5 
.................... #define RF_BITRATEMSB_200000          0x00 
.................... #define RF_BITRATELSB_200000          0xA0 
.................... #define RF_BITRATEMSB_250000          0x00 
.................... #define RF_BITRATELSB_250000          0x80 
.................... #define RF_BITRATEMSB_300000          0x00 
.................... #define RF_BITRATELSB_300000          0x6B 
.................... #define RF_BITRATEMSB_32768           0x03 
.................... #define RF_BITRATELSB_32768           0xD1 
.................... // custom bit rates 
.................... #define RF_BITRATEMSB_55555           0x02 
.................... #define RF_BITRATELSB_55555           0x40 
.................... #define RF_BITRATEMSB_200KBPS         0x00 
.................... #define RF_BITRATELSB_200KBPS         0xa0 
....................  
....................  
.................... // RegFdev - frequency deviation (Hz) 
.................... #define RF_FDEVMSB_2000             0x00 
.................... #define RF_FDEVLSB_2000             0x21 
.................... #define RF_FDEVMSB_5000             0x00  // Default 
.................... #define RF_FDEVLSB_5000             0x52  // Default 
.................... #define RF_FDEVMSB_7500             0x00 
.................... #define RF_FDEVLSB_7500             0x7B 
.................... #define RF_FDEVMSB_10000            0x00 
.................... #define RF_FDEVLSB_10000            0xA4 
.................... #define RF_FDEVMSB_15000            0x00 
.................... #define RF_FDEVLSB_15000            0xF6 
.................... #define RF_FDEVMSB_20000            0x01 
.................... #define RF_FDEVLSB_20000            0x48 
.................... #define RF_FDEVMSB_25000            0x01 
.................... #define RF_FDEVLSB_25000            0x9A 
.................... #define RF_FDEVMSB_30000            0x01 
.................... #define RF_FDEVLSB_30000            0xEC 
.................... #define RF_FDEVMSB_35000            0x02 
.................... #define RF_FDEVLSB_35000            0x3D 
.................... #define RF_FDEVMSB_40000            0x02 
.................... #define RF_FDEVLSB_40000            0x8F 
.................... #define RF_FDEVMSB_45000            0x02 
.................... #define RF_FDEVLSB_45000            0xE1 
.................... #define RF_FDEVMSB_50000            0x03 
.................... #define RF_FDEVLSB_50000            0x33 
.................... #define RF_FDEVMSB_55000            0x03 
.................... #define RF_FDEVLSB_55000            0x85 
.................... #define RF_FDEVMSB_60000            0x03 
.................... #define RF_FDEVLSB_60000            0xD7 
.................... #define RF_FDEVMSB_65000            0x04 
.................... #define RF_FDEVLSB_65000            0x29 
.................... #define RF_FDEVMSB_70000            0x04 
.................... #define RF_FDEVLSB_70000            0x7B 
.................... #define RF_FDEVMSB_75000            0x04 
.................... #define RF_FDEVLSB_75000            0xCD 
.................... #define RF_FDEVMSB_80000            0x05 
.................... #define RF_FDEVLSB_80000            0x1F 
.................... #define RF_FDEVMSB_85000            0x05 
.................... #define RF_FDEVLSB_85000            0x71 
.................... #define RF_FDEVMSB_90000            0x05 
.................... #define RF_FDEVLSB_90000            0xC3 
.................... #define RF_FDEVMSB_95000            0x06 
.................... #define RF_FDEVLSB_95000            0x14 
.................... #define RF_FDEVMSB_100000           0x06 
.................... #define RF_FDEVLSB_100000           0x66 
.................... #define RF_FDEVMSB_110000           0x07 
.................... #define RF_FDEVLSB_110000           0x0A 
.................... #define RF_FDEVMSB_120000           0x07 
.................... #define RF_FDEVLSB_120000           0xAE 
.................... #define RF_FDEVMSB_130000           0x08 
.................... #define RF_FDEVLSB_130000           0x52 
.................... #define RF_FDEVMSB_140000           0x08 
.................... #define RF_FDEVLSB_140000           0xF6 
.................... #define RF_FDEVMSB_150000           0x09 
.................... #define RF_FDEVLSB_150000           0x9A 
.................... #define RF_FDEVMSB_160000           0x0A 
.................... #define RF_FDEVLSB_160000           0x3D 
.................... #define RF_FDEVMSB_170000           0x0A 
.................... #define RF_FDEVLSB_170000           0xE1 
.................... #define RF_FDEVMSB_180000           0x0B 
.................... #define RF_FDEVLSB_180000           0x85 
.................... #define RF_FDEVMSB_190000           0x0C 
.................... #define RF_FDEVLSB_190000           0x29 
.................... #define RF_FDEVMSB_200000           0x0C 
.................... #define RF_FDEVLSB_200000           0xCD 
.................... #define RF_FDEVMSB_210000           0x0D 
.................... #define RF_FDEVLSB_210000           0x71 
.................... #define RF_FDEVMSB_220000           0x0E 
.................... #define RF_FDEVLSB_220000           0x14 
.................... #define RF_FDEVMSB_230000           0x0E 
.................... #define RF_FDEVLSB_230000           0xB8 
.................... #define RF_FDEVMSB_240000           0x0F 
.................... #define RF_FDEVLSB_240000           0x5C 
.................... #define RF_FDEVMSB_250000           0x10 
.................... #define RF_FDEVLSB_250000           0x00 
.................... #define RF_FDEVMSB_260000           0x10 
.................... #define RF_FDEVLSB_260000           0xA4 
.................... #define RF_FDEVMSB_270000           0x11 
.................... #define RF_FDEVLSB_270000           0x48 
.................... #define RF_FDEVMSB_280000           0x11 
.................... #define RF_FDEVLSB_280000           0xEC 
.................... #define RF_FDEVMSB_290000           0x12 
.................... #define RF_FDEVLSB_290000           0x8F 
.................... #define RF_FDEVMSB_300000           0x13 
.................... #define RF_FDEVLSB_300000           0x33 
....................  
....................  
.................... // RegFrf (MHz) - carrier frequency 
.................... // 315Mhz band 
.................... #define RF_FRFMSB_314             0x4E 
.................... #define RF_FRFMID_314             0x80 
.................... #define RF_FRFLSB_314             0x00 
.................... #define RF_FRFMSB_315             0x4E 
.................... #define RF_FRFMID_315             0xC0 
.................... #define RF_FRFLSB_315             0x00 
.................... #define RF_FRFMSB_316             0x4F 
.................... #define RF_FRFMID_316             0x00 
.................... #define RF_FRFLSB_316             0x00 
.................... // 433mhz band 
.................... #define RF_FRFMSB_433             0x6C 
.................... #define RF_FRFMID_433             0x40 
.................... #define RF_FRFLSB_433             0x00 
.................... #define RF_FRFMSB_434             0x6C 
.................... #define RF_FRFMID_434             0x80 
.................... #define RF_FRFLSB_434             0x00 
.................... #define RF_FRFMSB_435             0x6C 
.................... #define RF_FRFMID_435             0xC0 
.................... #define RF_FRFLSB_435             0x00 
.................... // 868Mhz band 
.................... #define RF_FRFMSB_863             0xD7 
.................... #define RF_FRFMID_863             0xC0 
.................... #define RF_FRFLSB_863             0x00 
.................... #define RF_FRFMSB_864             0xD8 
.................... #define RF_FRFMID_864             0x00 
.................... #define RF_FRFLSB_864             0x00 
.................... #define RF_FRFMSB_865             0xD8 
.................... #define RF_FRFMID_865             0x40 
.................... #define RF_FRFLSB_865             0x00 
.................... #define RF_FRFMSB_866             0xD8 
.................... #define RF_FRFMID_866             0x80 
.................... #define RF_FRFLSB_866             0x00 
.................... #define RF_FRFMSB_867             0xD8 
.................... #define RF_FRFMID_867             0xC0 
.................... #define RF_FRFLSB_867             0x00 
.................... #define RF_FRFMSB_868             0xD9 
.................... #define RF_FRFMID_868             0x00 
.................... #define RF_FRFLSB_868             0x00 
.................... #define RF_FRFMSB_869             0xD9 
.................... #define RF_FRFMID_869             0x40 
.................... #define RF_FRFLSB_869             0x00 
.................... #define RF_FRFMSB_870             0xD9 
.................... #define RF_FRFMID_870             0x80 
.................... #define RF_FRFLSB_870             0x00 
.................... // 915Mhz band 
.................... #define RF_FRFMSB_902             0xE1 
.................... #define RF_FRFMID_902             0x80 
.................... #define RF_FRFLSB_902             0x00 
.................... #define RF_FRFMSB_903             0xE1 
.................... #define RF_FRFMID_903             0xC0 
.................... #define RF_FRFLSB_903             0x00 
.................... #define RF_FRFMSB_904             0xE2 
.................... #define RF_FRFMID_904             0x00 
.................... #define RF_FRFLSB_904             0x00 
.................... #define RF_FRFMSB_905             0xE2 
.................... #define RF_FRFMID_905             0x40 
.................... #define RF_FRFLSB_905             0x00 
.................... #define RF_FRFMSB_906             0xE2 
.................... #define RF_FRFMID_906             0x80 
.................... #define RF_FRFLSB_906             0x00 
.................... #define RF_FRFMSB_907             0xE2 
.................... #define RF_FRFMID_907             0xC0 
.................... #define RF_FRFLSB_907             0x00 
.................... #define RF_FRFMSB_908             0xE3 
.................... #define RF_FRFMID_908             0x00 
.................... #define RF_FRFLSB_908             0x00 
.................... #define RF_FRFMSB_909             0xE3 
.................... #define RF_FRFMID_909             0x40 
.................... #define RF_FRFLSB_909             0x00 
.................... #define RF_FRFMSB_910             0xE3 
.................... #define RF_FRFMID_910             0x80 
.................... #define RF_FRFLSB_910             0x00 
.................... #define RF_FRFMSB_911             0xE3 
.................... #define RF_FRFMID_911             0xC0 
.................... #define RF_FRFLSB_911             0x00 
.................... #define RF_FRFMSB_912             0xE4 
.................... #define RF_FRFMID_912             0x00 
.................... #define RF_FRFLSB_912             0x00 
.................... #define RF_FRFMSB_913             0xE4 
.................... #define RF_FRFMID_913             0x40 
.................... #define RF_FRFLSB_913             0x00 
.................... #define RF_FRFMSB_914             0xE4 
.................... #define RF_FRFMID_914             0x80 
.................... #define RF_FRFLSB_914             0x00 
.................... #define RF_FRFMSB_915             0xE4  // Default 
.................... #define RF_FRFMID_915             0xC0  // Default 
.................... #define RF_FRFLSB_915             0x00  // Default 
.................... #define RF_FRFMSB_916             0xE5 
.................... #define RF_FRFMID_916             0x00 
.................... #define RF_FRFLSB_916             0x00 
.................... #define RF_FRFMSB_917             0xE5 
.................... #define RF_FRFMID_917             0x40 
.................... #define RF_FRFLSB_917             0x00 
.................... #define RF_FRFMSB_918             0xE5 
.................... #define RF_FRFMID_918             0x80 
.................... #define RF_FRFLSB_918             0x00 
.................... #define RF_FRFMSB_919             0xE5 
.................... #define RF_FRFMID_919             0xC0 
.................... #define RF_FRFLSB_919             0x00 
.................... #define RF_FRFMSB_920             0xE6 
.................... #define RF_FRFMID_920             0x00 
.................... #define RF_FRFLSB_920             0x00 
.................... #define RF_FRFMSB_921             0xE6 
.................... #define RF_FRFMID_921             0x40 
.................... #define RF_FRFLSB_921             0x00 
.................... #define RF_FRFMSB_922             0xE6 
.................... #define RF_FRFMID_922             0x80 
.................... #define RF_FRFLSB_922             0x00 
.................... #define RF_FRFMSB_923             0xE6 
.................... #define RF_FRFMID_923             0xC0 
.................... #define RF_FRFLSB_923             0x00 
.................... #define RF_FRFMSB_924             0xE7 
.................... #define RF_FRFMID_924             0x00 
.................... #define RF_FRFLSB_924             0x00 
.................... #define RF_FRFMSB_925             0xE7 
.................... #define RF_FRFMID_925             0x40 
.................... #define RF_FRFLSB_925             0x00 
.................... #define RF_FRFMSB_926             0xE7 
.................... #define RF_FRFMID_926             0x80 
.................... #define RF_FRFLSB_926             0x00 
.................... #define RF_FRFMSB_927             0xE7 
.................... #define RF_FRFMID_927             0xC0 
.................... #define RF_FRFLSB_927             0x00 
.................... #define RF_FRFMSB_928             0xE8 
.................... #define RF_FRFMID_928             0x00 
.................... #define RF_FRFLSB_928             0x00 
....................  
....................  
.................... // RegOsc1 
.................... #define RF_OSC1_RCCAL_START       0x80 
.................... #define RF_OSC1_RCCAL_DONE        0x40 
....................  
....................  
.................... // RegAfcCtrl 
.................... #define RF_AFCCTRL_LOWBETA_OFF    0x00  // Default 
.................... #define RF_AFCCTRL_LOWBETA_ON     0x20 
....................  
....................  
.................... // RegLowBat 
.................... #define RF_LOWBAT_MONITOR         0x10 
.................... #define RF_LOWBAT_ON              0x08 
.................... #define RF_LOWBAT_OFF             0x00  // Default 
....................  
.................... #define RF_LOWBAT_TRIM_1695       0x00 
.................... #define RF_LOWBAT_TRIM_1764       0x01 
.................... #define RF_LOWBAT_TRIM_1835       0x02  // Default 
.................... #define RF_LOWBAT_TRIM_1905       0x03 
.................... #define RF_LOWBAT_TRIM_1976       0x04 
.................... #define RF_LOWBAT_TRIM_2045       0x05 
.................... #define RF_LOWBAT_TRIM_2116       0x06 
.................... #define RF_LOWBAT_TRIM_2185       0x07 
....................  
....................  
.................... // RegListen1 
.................... #define RF_LISTEN1_RESOL_64       0x50 
.................... #define RF_LISTEN1_RESOL_4100     0xA0  // Default 
.................... #define RF_LISTEN1_RESOL_262000   0xF0 
....................  
.................... #define RF_LISTEN1_RESOL_IDLE_64     0x40 
.................... #define RF_LISTEN1_RESOL_IDLE_4100   0x80  // Default 
.................... #define RF_LISTEN1_RESOL_IDLE_262000 0xC0 
....................  
.................... #define RF_LISTEN1_RESOL_RX_64       0x10 
.................... #define RF_LISTEN1_RESOL_RX_4100     0x20  // Default 
.................... #define RF_LISTEN1_RESOL_RX_262000   0x30 
....................  
.................... #define RF_LISTEN1_CRITERIA_RSSI          0x00  // Default 
.................... #define RF_LISTEN1_CRITERIA_RSSIANDSYNC   0x08 
....................  
.................... #define RF_LISTEN1_END_00                 0x00 
.................... #define RF_LISTEN1_END_01                 0x02  // Default 
.................... #define RF_LISTEN1_END_10                 0x04 
....................  
....................  
.................... // RegListen2 
.................... #define RF_LISTEN2_COEFIDLE_VALUE         0xF5 // Default 
....................  
....................  
.................... // RegListen3 
.................... #define RF_LISTEN3_COEFRX_VALUE           0x20 // Default 
....................  
....................  
.................... // RegVersion 
.................... #define RF_VERSION_VER        0x24  // Default 
....................  
....................  
.................... // RegPaLevel 
.................... #define RF_PALEVEL_PA0_ON     0x80  // Default 
.................... #define RF_PALEVEL_PA0_OFF    0x00 
.................... #define RF_PALEVEL_PA1_ON     0x40 
.................... #define RF_PALEVEL_PA1_OFF    0x00  // Default 
.................... #define RF_PALEVEL_PA2_ON     0x20 
.................... #define RF_PALEVEL_PA2_OFF    0x00  // Default 
....................  
.................... #define RF_PALEVEL_OUTPUTPOWER_00000      0x00 
.................... #define RF_PALEVEL_OUTPUTPOWER_00001      0x01 
.................... #define RF_PALEVEL_OUTPUTPOWER_00010      0x02 
.................... #define RF_PALEVEL_OUTPUTPOWER_00011      0x03 
.................... #define RF_PALEVEL_OUTPUTPOWER_00100      0x04 
.................... #define RF_PALEVEL_OUTPUTPOWER_00101      0x05 
.................... #define RF_PALEVEL_OUTPUTPOWER_00110      0x06 
.................... #define RF_PALEVEL_OUTPUTPOWER_00111      0x07 
.................... #define RF_PALEVEL_OUTPUTPOWER_01000      0x08 
.................... #define RF_PALEVEL_OUTPUTPOWER_01001      0x09 
.................... #define RF_PALEVEL_OUTPUTPOWER_01010      0x0A 
.................... #define RF_PALEVEL_OUTPUTPOWER_01011      0x0B 
.................... #define RF_PALEVEL_OUTPUTPOWER_01100      0x0C 
.................... #define RF_PALEVEL_OUTPUTPOWER_01101      0x0D 
.................... #define RF_PALEVEL_OUTPUTPOWER_01110      0x0E 
.................... #define RF_PALEVEL_OUTPUTPOWER_01111      0x0F 
.................... #define RF_PALEVEL_OUTPUTPOWER_10000      0x10 
.................... #define RF_PALEVEL_OUTPUTPOWER_10001      0x11 
.................... #define RF_PALEVEL_OUTPUTPOWER_10010      0x12 
.................... #define RF_PALEVEL_OUTPUTPOWER_10011      0x13 
.................... #define RF_PALEVEL_OUTPUTPOWER_10100      0x14 
.................... #define RF_PALEVEL_OUTPUTPOWER_10101      0x15 
.................... #define RF_PALEVEL_OUTPUTPOWER_10110      0x16 
.................... #define RF_PALEVEL_OUTPUTPOWER_10111      0x17 
.................... #define RF_PALEVEL_OUTPUTPOWER_11000      0x18 
.................... #define RF_PALEVEL_OUTPUTPOWER_11001      0x19 
.................... #define RF_PALEVEL_OUTPUTPOWER_11010      0x1A 
.................... #define RF_PALEVEL_OUTPUTPOWER_11011      0x1B 
.................... #define RF_PALEVEL_OUTPUTPOWER_11100      0x1C 
.................... #define RF_PALEVEL_OUTPUTPOWER_11101      0x1D 
.................... #define RF_PALEVEL_OUTPUTPOWER_11110      0x1E 
.................... #define RF_PALEVEL_OUTPUTPOWER_11111      0x1F  // Default 
....................  
....................  
.................... // RegPaRamp 
.................... #define RF_PARAMP_3400            0x00 
.................... #define RF_PARAMP_2000            0x01 
.................... #define RF_PARAMP_1000            0x02 
.................... #define RF_PARAMP_500             0x03 
.................... #define RF_PARAMP_250             0x04 
.................... #define RF_PARAMP_125             0x05 
.................... #define RF_PARAMP_100             0x06 
.................... #define RF_PARAMP_62              0x07 
.................... #define RF_PARAMP_50              0x08 
.................... #define RF_PARAMP_40              0x09  // Default 
.................... #define RF_PARAMP_31              0x0A 
.................... #define RF_PARAMP_25              0x0B 
.................... #define RF_PARAMP_20              0x0C 
.................... #define RF_PARAMP_15              0x0D 
.................... #define RF_PARAMP_12              0x0E 
.................... #define RF_PARAMP_10              0x0F 
....................  
....................  
.................... // RegOcp 
.................... #define RF_OCP_OFF                0x0F 
.................... #define RF_OCP_ON                 0x1A  // Default 
....................  
.................... #define RF_OCP_TRIM_45            0x00 
.................... #define RF_OCP_TRIM_50            0x01 
.................... #define RF_OCP_TRIM_55            0x02 
.................... #define RF_OCP_TRIM_60            0x03 
.................... #define RF_OCP_TRIM_65            0x04 
.................... #define RF_OCP_TRIM_70            0x05 
.................... #define RF_OCP_TRIM_75            0x06 
.................... #define RF_OCP_TRIM_80            0x07 
.................... #define RF_OCP_TRIM_85            0x08 
.................... #define RF_OCP_TRIM_90            0x09 
.................... #define RF_OCP_TRIM_95            0x0A  // Default 
.................... #define RF_OCP_TRIM_100           0x0B 
.................... #define RF_OCP_TRIM_105           0x0C 
.................... #define RF_OCP_TRIM_110           0x0D 
.................... #define RF_OCP_TRIM_115           0x0E 
.................... #define RF_OCP_TRIM_120           0x0F 
....................  
....................  
.................... // RegAgcRef - not present on RFM69/SX1231 
.................... #define RF_AGCREF_AUTO_ON         0x40  // Default 
.................... #define RF_AGCREF_AUTO_OFF        0x00 
....................  
.................... #define RF_AGCREF_LEVEL_MINUS80   0x00  // Default 
.................... #define RF_AGCREF_LEVEL_MINUS81   0x01 
.................... #define RF_AGCREF_LEVEL_MINUS82   0x02 
.................... #define RF_AGCREF_LEVEL_MINUS83   0x03 
.................... #define RF_AGCREF_LEVEL_MINUS84   0x04 
.................... #define RF_AGCREF_LEVEL_MINUS85   0x05 
.................... #define RF_AGCREF_LEVEL_MINUS86   0x06 
.................... #define RF_AGCREF_LEVEL_MINUS87   0x07 
.................... #define RF_AGCREF_LEVEL_MINUS88   0x08 
.................... #define RF_AGCREF_LEVEL_MINUS89   0x09 
.................... #define RF_AGCREF_LEVEL_MINUS90   0x0A 
.................... #define RF_AGCREF_LEVEL_MINUS91   0x0B 
.................... #define RF_AGCREF_LEVEL_MINUS92   0x0C 
.................... #define RF_AGCREF_LEVEL_MINUS93   0x0D 
.................... #define RF_AGCREF_LEVEL_MINUS94   0x0E 
.................... #define RF_AGCREF_LEVEL_MINUS95   0x0F 
.................... #define RF_AGCREF_LEVEL_MINUS96   0x10 
.................... #define RF_AGCREF_LEVEL_MINUS97   0x11 
.................... #define RF_AGCREF_LEVEL_MINUS98   0x12 
.................... #define RF_AGCREF_LEVEL_MINUS99   0x13 
.................... #define RF_AGCREF_LEVEL_MINUS100  0x14 
.................... #define RF_AGCREF_LEVEL_MINUS101  0x15 
.................... #define RF_AGCREF_LEVEL_MINUS102  0x16 
.................... #define RF_AGCREF_LEVEL_MINUS103  0x17 
.................... #define RF_AGCREF_LEVEL_MINUS104  0x18 
.................... #define RF_AGCREF_LEVEL_MINUS105  0x19 
.................... #define RF_AGCREF_LEVEL_MINUS106  0x1A 
.................... #define RF_AGCREF_LEVEL_MINUS107  0x1B 
.................... #define RF_AGCREF_LEVEL_MINUS108  0x1C 
.................... #define RF_AGCREF_LEVEL_MINUS109  0x1D 
.................... #define RF_AGCREF_LEVEL_MINUS110  0x1E 
.................... #define RF_AGCREF_LEVEL_MINUS111  0x1F 
.................... #define RF_AGCREF_LEVEL_MINUS112  0x20 
.................... #define RF_AGCREF_LEVEL_MINUS113  0x21 
.................... #define RF_AGCREF_LEVEL_MINUS114  0x22 
.................... #define RF_AGCREF_LEVEL_MINUS115  0x23 
.................... #define RF_AGCREF_LEVEL_MINUS116  0x24 
.................... #define RF_AGCREF_LEVEL_MINUS117  0x25 
.................... #define RF_AGCREF_LEVEL_MINUS118  0x26 
.................... #define RF_AGCREF_LEVEL_MINUS119  0x27 
.................... #define RF_AGCREF_LEVEL_MINUS120  0x28 
.................... #define RF_AGCREF_LEVEL_MINUS121  0x29 
.................... #define RF_AGCREF_LEVEL_MINUS122  0x2A 
.................... #define RF_AGCREF_LEVEL_MINUS123  0x2B 
.................... #define RF_AGCREF_LEVEL_MINUS124  0x2C 
.................... #define RF_AGCREF_LEVEL_MINUS125  0x2D 
.................... #define RF_AGCREF_LEVEL_MINUS126  0x2E 
.................... #define RF_AGCREF_LEVEL_MINUS127  0x2F 
.................... #define RF_AGCREF_LEVEL_MINUS128  0x30 
.................... #define RF_AGCREF_LEVEL_MINUS129  0x31 
.................... #define RF_AGCREF_LEVEL_MINUS130  0x32 
.................... #define RF_AGCREF_LEVEL_MINUS131  0x33 
.................... #define RF_AGCREF_LEVEL_MINUS132  0x34 
.................... #define RF_AGCREF_LEVEL_MINUS133  0x35 
.................... #define RF_AGCREF_LEVEL_MINUS134  0x36 
.................... #define RF_AGCREF_LEVEL_MINUS135  0x37 
.................... #define RF_AGCREF_LEVEL_MINUS136  0x38 
.................... #define RF_AGCREF_LEVEL_MINUS137  0x39 
.................... #define RF_AGCREF_LEVEL_MINUS138  0x3A 
.................... #define RF_AGCREF_LEVEL_MINUS139  0x3B 
.................... #define RF_AGCREF_LEVEL_MINUS140  0x3C 
.................... #define RF_AGCREF_LEVEL_MINUS141  0x3D 
.................... #define RF_AGCREF_LEVEL_MINUS142  0x3E 
.................... #define RF_AGCREF_LEVEL_MINUS143  0x3F 
....................  
....................  
.................... // RegAgcThresh1 - not present on RFM69/SX1231 
.................... #define RF_AGCTHRESH1_SNRMARGIN_000   0x00 
.................... #define RF_AGCTHRESH1_SNRMARGIN_001   0x20 
.................... #define RF_AGCTHRESH1_SNRMARGIN_010   0x40 
.................... #define RF_AGCTHRESH1_SNRMARGIN_011   0x60 
.................... #define RF_AGCTHRESH1_SNRMARGIN_100   0x80 
.................... #define RF_AGCTHRESH1_SNRMARGIN_101   0xA0  // Default 
.................... #define RF_AGCTHRESH1_SNRMARGIN_110   0xC0 
.................... #define RF_AGCTHRESH1_SNRMARGIN_111   0xE0 
....................  
.................... #define RF_AGCTHRESH1_STEP1_0         0x00 
.................... #define RF_AGCTHRESH1_STEP1_1         0x01 
.................... #define RF_AGCTHRESH1_STEP1_2         0x02 
.................... #define RF_AGCTHRESH1_STEP1_3         0x03 
.................... #define RF_AGCTHRESH1_STEP1_4         0x04 
.................... #define RF_AGCTHRESH1_STEP1_5         0x05 
.................... #define RF_AGCTHRESH1_STEP1_6         0x06 
.................... #define RF_AGCTHRESH1_STEP1_7         0x07 
.................... #define RF_AGCTHRESH1_STEP1_8         0x08 
.................... #define RF_AGCTHRESH1_STEP1_9         0x09 
.................... #define RF_AGCTHRESH1_STEP1_10        0x0A 
.................... #define RF_AGCTHRESH1_STEP1_11        0x0B 
.................... #define RF_AGCTHRESH1_STEP1_12        0x0C 
.................... #define RF_AGCTHRESH1_STEP1_13        0x0D 
.................... #define RF_AGCTHRESH1_STEP1_14        0x0E 
.................... #define RF_AGCTHRESH1_STEP1_15        0x0F 
.................... #define RF_AGCTHRESH1_STEP1_16        0x10  // Default 
.................... #define RF_AGCTHRESH1_STEP1_17        0x11 
.................... #define RF_AGCTHRESH1_STEP1_18        0x12 
.................... #define RF_AGCTHRESH1_STEP1_19        0x13 
.................... #define RF_AGCTHRESH1_STEP1_20        0x14 
.................... #define RF_AGCTHRESH1_STEP1_21        0x15 
.................... #define RF_AGCTHRESH1_STEP1_22        0x16 
.................... #define RF_AGCTHRESH1_STEP1_23        0x17 
.................... #define RF_AGCTHRESH1_STEP1_24        0x18 
.................... #define RF_AGCTHRESH1_STEP1_25        0x19 
.................... #define RF_AGCTHRESH1_STEP1_26        0x1A 
.................... #define RF_AGCTHRESH1_STEP1_27        0x1B 
.................... #define RF_AGCTHRESH1_STEP1_28        0x1C 
.................... #define RF_AGCTHRESH1_STEP1_29        0x1D 
.................... #define RF_AGCTHRESH1_STEP1_30        0x1E 
.................... #define RF_AGCTHRESH1_STEP1_31        0x1F 
....................  
....................  
.................... // RegAgcThresh2 - not present on RFM69/SX1231 
.................... #define RF_AGCTHRESH2_STEP2_0         0x00 
.................... #define RF_AGCTHRESH2_STEP2_1         0x10 
.................... #define RF_AGCTHRESH2_STEP2_2         0x20 
.................... #define RF_AGCTHRESH2_STEP2_3         0x30  // XXX wrong -- Default 
.................... #define RF_AGCTHRESH2_STEP2_4         0x40 
.................... #define RF_AGCTHRESH2_STEP2_5         0x50 
.................... #define RF_AGCTHRESH2_STEP2_6         0x60 
.................... #define RF_AGCTHRESH2_STEP2_7         0x70  // default 
.................... #define RF_AGCTHRESH2_STEP2_8         0x80 
.................... #define RF_AGCTHRESH2_STEP2_9         0x90 
.................... #define RF_AGCTHRESH2_STEP2_10        0xA0 
.................... #define RF_AGCTHRESH2_STEP2_11        0xB0 
.................... #define RF_AGCTHRESH2_STEP2_12        0xC0 
.................... #define RF_AGCTHRESH2_STEP2_13        0xD0 
.................... #define RF_AGCTHRESH2_STEP2_14        0xE0 
.................... #define RF_AGCTHRESH2_STEP2_15        0xF0 
....................  
.................... #define RF_AGCTHRESH2_STEP3_0         0x00 
.................... #define RF_AGCTHRESH2_STEP3_1         0x01 
.................... #define RF_AGCTHRESH2_STEP3_2         0x02 
.................... #define RF_AGCTHRESH2_STEP3_3         0x03 
.................... #define RF_AGCTHRESH2_STEP3_4         0x04 
.................... #define RF_AGCTHRESH2_STEP3_5         0x05 
.................... #define RF_AGCTHRESH2_STEP3_6         0x06 
.................... #define RF_AGCTHRESH2_STEP3_7         0x07 
.................... #define RF_AGCTHRESH2_STEP3_8         0x08 
.................... #define RF_AGCTHRESH2_STEP3_9         0x09 
.................... #define RF_AGCTHRESH2_STEP3_10        0x0A 
.................... #define RF_AGCTHRESH2_STEP3_11        0x0B  // Default 
.................... #define RF_AGCTHRESH2_STEP3_12        0x0C 
.................... #define RF_AGCTHRESH2_STEP3_13        0x0D 
.................... #define RF_AGCTHRESH2_STEP3_14        0x0E 
.................... #define RF_AGCTHRESH2_STEP3_15        0x0F 
....................  
....................  
.................... // RegAgcThresh3 - not present on RFM69/SX1231 
.................... #define RF_AGCTHRESH3_STEP4_0         0x00 
.................... #define RF_AGCTHRESH3_STEP4_1         0x10 
.................... #define RF_AGCTHRESH3_STEP4_2         0x20 
.................... #define RF_AGCTHRESH3_STEP4_3         0x30 
.................... #define RF_AGCTHRESH3_STEP4_4         0x40 
.................... #define RF_AGCTHRESH3_STEP4_5         0x50 
.................... #define RF_AGCTHRESH3_STEP4_6         0x60 
.................... #define RF_AGCTHRESH3_STEP4_7         0x70 
.................... #define RF_AGCTHRESH3_STEP4_8         0x80 
.................... #define RF_AGCTHRESH3_STEP4_9         0x90  // Default 
.................... #define RF_AGCTHRESH3_STEP4_10        0xA0 
.................... #define RF_AGCTHRESH3_STEP4_11        0xB0 
.................... #define RF_AGCTHRESH3_STEP4_12        0xC0 
.................... #define RF_AGCTHRESH3_STEP4_13        0xD0 
.................... #define RF_AGCTHRESH3_STEP4_14        0xE0 
.................... #define RF_AGCTHRESH3_STEP4_15        0xF0 
....................  
.................... #define RF_AGCTHRESH3_STEP5_0         0x00 
.................... #define RF_AGCTHRESH3_STEP5_1         0x01 
.................... #define RF_AGCTHRESH3_STEP5_2         0x02 
.................... #define RF_AGCTHRESH3_STEP5_3         0x03 
.................... #define RF_AGCTHRESH3_STEP5_4         0x04 
.................... #define RF_AGCTHRESH3_STEP5_5         0x05 
.................... #define RF_AGCTHRESH3_STEP5_6         0x06 
.................... #define RF_AGCTHRESH3_STEP5_7         0x07 
.................... #define RF_AGCTHRES33_STEP5_8         0x08 
.................... #define RF_AGCTHRESH3_STEP5_9         0x09 
.................... #define RF_AGCTHRESH3_STEP5_10        0x0A 
.................... #define RF_AGCTHRESH3_STEP5_11        0x0B  // Default 
.................... #define RF_AGCTHRESH3_STEP5_12        0x0C 
.................... #define RF_AGCTHRESH3_STEP5_13        0x0D 
.................... #define RF_AGCTHRESH3_STEP5_14        0x0E 
.................... #define RF_AGCTHRESH3_STEP5_15        0x0F 
....................  
....................  
.................... // RegLna 
.................... #define RF_LNA_ZIN_50                 0x00  // Reset value 
.................... #define RF_LNA_ZIN_200                0x80  // Recommended default 
....................  
.................... #define RF_LNA_LOWPOWER_OFF           0x00  // Default 
.................... #define RF_LNA_LOWPOWER_ON            0x40 
....................  
.................... #define RF_LNA_CURRENTGAIN            0x08 
....................  
.................... #define RF_LNA_GAINSELECT_AUTO        0x00  // Default 
.................... #define RF_LNA_GAINSELECT_MAX         0x01 
.................... #define RF_LNA_GAINSELECT_MAXMINUS6   0x02 
.................... #define RF_LNA_GAINSELECT_MAXMINUS12  0x03 
.................... #define RF_LNA_GAINSELECT_MAXMINUS24  0x04 
.................... #define RF_LNA_GAINSELECT_MAXMINUS36  0x05 
.................... #define RF_LNA_GAINSELECT_MAXMINUS48  0x06 
....................  
....................  
.................... // RegRxBw 
.................... #define RF_RXBW_DCCFREQ_000           0x00 
.................... #define RF_RXBW_DCCFREQ_001           0x20 
.................... #define RF_RXBW_DCCFREQ_010           0x40  // Recommended default 
.................... #define RF_RXBW_DCCFREQ_011           0x60 
.................... #define RF_RXBW_DCCFREQ_100           0x80  // Reset value 
.................... #define RF_RXBW_DCCFREQ_101           0xA0 
.................... #define RF_RXBW_DCCFREQ_110           0xC0 
.................... #define RF_RXBW_DCCFREQ_111           0xE0 
....................  
.................... #define RF_RXBW_MANT_16               0x00  // Reset value 
.................... #define RF_RXBW_MANT_20               0x08 
.................... #define RF_RXBW_MANT_24               0x10  // Recommended default 
....................  
.................... #define RF_RXBW_EXP_0                 0x00 
.................... #define RF_RXBW_EXP_1                 0x01 
.................... #define RF_RXBW_EXP_2                 0x02 
.................... #define RF_RXBW_EXP_3                 0x03 
.................... #define RF_RXBW_EXP_4                 0x04 
.................... #define RF_RXBW_EXP_5                 0x05  // Recommended default 
.................... #define RF_RXBW_EXP_6                 0x06  // Reset value 
.................... #define RF_RXBW_EXP_7                 0x07 
....................  
....................  
.................... // RegAfcBw 
.................... #define RF_AFCBW_DCCFREQAFC_000       0x00 
.................... #define RF_AFCBW_DCCFREQAFC_001       0x20 
.................... #define RF_AFCBW_DCCFREQAFC_010       0x40 
.................... #define RF_AFCBW_DCCFREQAFC_011       0x60 
.................... #define RF_AFCBW_DCCFREQAFC_100       0x80  // Default 
.................... #define RF_AFCBW_DCCFREQAFC_101       0xA0 
.................... #define RF_AFCBW_DCCFREQAFC_110       0xC0 
.................... #define RF_AFCBW_DCCFREQAFC_111       0xE0 
....................  
.................... #define RF_AFCBW_MANTAFC_16           0x00 
.................... #define RF_AFCBW_MANTAFC_20           0x08  // Default 
.................... #define RF_AFCBW_MANTAFC_24           0x10 
....................  
.................... #define RF_AFCBW_EXPAFC_0             0x00 
.................... #define RF_AFCBW_EXPAFC_1             0x01 
.................... #define RF_AFCBW_EXPAFC_2             0x02  // Reset value 
.................... #define RF_AFCBW_EXPAFC_3             0x03  // Recommended default 
.................... #define RF_AFCBW_EXPAFC_4             0x04 
.................... #define RF_AFCBW_EXPAFC_5             0x05 
.................... #define RF_AFCBW_EXPAFC_6             0x06 
.................... #define RF_AFCBW_EXPAFC_7             0x07 
....................  
....................  
.................... // RegOokPeak 
.................... #define RF_OOKPEAK_THRESHTYPE_FIXED       0x00 
.................... #define RF_OOKPEAK_THRESHTYPE_PEAK        0x40  // Default 
.................... #define RF_OOKPEAK_THRESHTYPE_AVERAGE     0x80 
....................  
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_000     0x00  // Default 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_001     0x08 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_010     0x10 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_011     0x18 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_100     0x20 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_101     0x28 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_110     0x30 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_111     0x38 
....................  
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_000      0x00  // Default 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_001      0x01 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_010      0x02 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_011      0x03 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_100      0x04 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_101      0x05 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_110      0x06 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_111      0x07 
....................  
....................  
.................... // RegOokAvg 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_00    0x00 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_01    0x40 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_10    0x80  // Default 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_11    0xC0 
....................  
....................  
.................... // RegOokFix 
.................... #define RF_OOKFIX_FIXEDTHRESH_VALUE       0x06  // Default 
....................  
....................  
.................... // RegAfcFei 
.................... #define RF_AFCFEI_FEI_DONE                0x40 
.................... #define RF_AFCFEI_FEI_START               0x20 
.................... #define RF_AFCFEI_AFC_DONE                0x10 
.................... #define RF_AFCFEI_AFCAUTOCLEAR_ON         0x08 
.................... #define RF_AFCFEI_AFCAUTOCLEAR_OFF        0x00  // Default 
....................  
.................... #define RF_AFCFEI_AFCAUTO_ON              0x04 
.................... #define RF_AFCFEI_AFCAUTO_OFF             0x00  // Default 
....................  
.................... #define RF_AFCFEI_AFC_CLEAR               0x02 
.................... #define RF_AFCFEI_AFC_START               0x01 
....................  
....................  
.................... // RegRssiConfig 
.................... #define RF_RSSI_FASTRX_ON                 0x08  // not present on RFM69/SX1231 
.................... #define RF_RSSI_FASTRX_OFF                0x00  // Default 
....................  
.................... #define RF_RSSI_DONE                      0x02 
.................... #define RF_RSSI_START                     0x01 
....................  
....................  
.................... // RegDioMapping1 
.................... #define RF_DIOMAPPING1_DIO0_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO0_01            0x40 
.................... #define RF_DIOMAPPING1_DIO0_10            0x80 
.................... #define RF_DIOMAPPING1_DIO0_11            0xC0 
....................  
.................... #define RF_DIOMAPPING1_DIO1_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO1_01            0x10 
.................... #define RF_DIOMAPPING1_DIO1_10            0x20 
.................... #define RF_DIOMAPPING1_DIO1_11            0x30 
....................  
.................... #define RF_DIOMAPPING1_DIO2_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO2_01            0x04 
.................... #define RF_DIOMAPPING1_DIO2_10            0x08 
.................... #define RF_DIOMAPPING1_DIO2_11            0x0C 
....................  
.................... #define RF_DIOMAPPING1_DIO3_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO3_01            0x01 
.................... #define RF_DIOMAPPING1_DIO3_10            0x02 
.................... #define RF_DIOMAPPING1_DIO3_11            0x03 
....................  
....................  
.................... // RegDioMapping2 
.................... #define RF_DIOMAPPING2_DIO4_00            0x00  // Default 
.................... #define RF_DIOMAPPING2_DIO4_01            0x40 
.................... #define RF_DIOMAPPING2_DIO4_10            0x80 
.................... #define RF_DIOMAPPING2_DIO4_11            0xC0 
....................  
.................... #define RF_DIOMAPPING2_DIO5_00            0x00  // Default 
.................... #define RF_DIOMAPPING2_DIO5_01            0x10 
.................... #define RF_DIOMAPPING2_DIO5_10            0x20 
.................... #define RF_DIOMAPPING2_DIO5_11            0x30 
....................  
.................... #define RF_DIOMAPPING2_CLKOUT_32MHZ       0x00 
.................... #define RF_DIOMAPPING2_CLKOUT_16MHZ       0x01 
.................... #define RF_DIOMAPPING2_CLKOUT_8MHZ        0x02 
.................... #define RF_DIOMAPPING2_CLKOUT_4MHZ        0x03 
.................... #define RF_DIOMAPPING2_CLKOUT_2MHZ        0x04 
.................... #define RF_DIOMAPPING2_CLKOUT_1MHZ        0x05  // Reset value 
.................... #define RF_DIOMAPPING2_CLKOUT_RC          0x06 
.................... #define RF_DIOMAPPING2_CLKOUT_OFF         0x07  // Recommended default 
....................  
....................  
.................... // RegIrqFlags1 
.................... #define RF_IRQFLAGS1_MODEREADY            0x80 
.................... #define RF_IRQFLAGS1_RXREADY              0x40 
.................... #define RF_IRQFLAGS1_TXREADY              0x20 
.................... #define RF_IRQFLAGS1_PLLLOCK              0x10 
.................... #define RF_IRQFLAGS1_RSSI                 0x08 
.................... #define RF_IRQFLAGS1_TIMEOUT              0x04 
.................... #define RF_IRQFLAGS1_AUTOMODE             0x02 
.................... #define RF_IRQFLAGS1_SYNCADDRESSMATCH     0x01 
....................  
....................  
.................... // RegIrqFlags2 
.................... #define RF_IRQFLAGS2_FIFOFULL             0x80 
.................... #define RF_IRQFLAGS2_FIFONOTEMPTY         0x40 
.................... #define RF_IRQFLAGS2_FIFOLEVEL            0x20 
.................... #define RF_IRQFLAGS2_FIFOOVERRUN          0x10 
.................... #define RF_IRQFLAGS2_PACKETSENT           0x08 
.................... #define RF_IRQFLAGS2_PAYLOADREADY         0x04 
.................... #define RF_IRQFLAGS2_CRCOK                0x02 
.................... #define RF_IRQFLAGS2_LOWBAT               0x01  // not present on RFM69/SX1231 
....................  
....................  
.................... // RegRssiThresh 
.................... #define RF_RSSITHRESH_VALUE               0xE4  // Default 
....................  
....................  
.................... // RegRxTimeout1 
.................... #define RF_RXTIMEOUT1_RXSTART_VALUE       0x00  // Default 
....................  
....................  
.................... // RegRxTimeout2 
.................... #define RF_RXTIMEOUT2_RSSITHRESH_VALUE    0x00  // Default 
....................  
....................  
.................... // RegPreamble 
.................... #define RF_PREAMBLESIZE_MSB_VALUE         0x00  // Default 
.................... #define RF_PREAMBLESIZE_LSB_VALUE         0x03  // Default 
....................  
....................  
.................... // RegSyncConfig 
.................... #define RF_SYNC_ON                0x80  // Default 
.................... #define RF_SYNC_OFF               0x00 
....................  
.................... #define RF_SYNC_FIFOFILL_AUTO     0x00  // Default -- when sync interrupt occurs 
.................... #define RF_SYNC_FIFOFILL_MANUAL   0x40 
....................  
.................... #define RF_SYNC_SIZE_1            0x00 
.................... #define RF_SYNC_SIZE_2            0x08 
.................... #define RF_SYNC_SIZE_3            0x10 
.................... #define RF_SYNC_SIZE_4            0x18  // Default 
.................... #define RF_SYNC_SIZE_5            0x20 
.................... #define RF_SYNC_SIZE_6            0x28 
.................... #define RF_SYNC_SIZE_7            0x30 
.................... #define RF_SYNC_SIZE_8            0x38 
....................  
.................... #define RF_SYNC_TOL_0             0x00  // Default 
.................... #define RF_SYNC_TOL_1             0x01 
.................... #define RF_SYNC_TOL_2             0x02 
.................... #define RF_SYNC_TOL_3             0x03 
.................... #define RF_SYNC_TOL_4             0x04 
.................... #define RF_SYNC_TOL_5             0x05 
.................... #define RF_SYNC_TOL_6             0x06 
.................... #define RF_SYNC_TOL_7             0x07 
....................  
....................  
.................... // RegSyncValue1-8 
.................... #define RF_SYNC_BYTE1_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE2_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE3_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE4_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE5_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE6_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE7_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE8_VALUE       0x00  // Default 
....................  
....................  
.................... // RegPacketConfig1 
.................... #define RF_PACKET1_FORMAT_FIXED       0x00  // Default 
.................... #define RF_PACKET1_FORMAT_VARIABLE    0x80 
....................  
.................... #define RF_PACKET1_DCFREE_OFF         0x00  // Default 
.................... #define RF_PACKET1_DCFREE_MANCHESTER  0x20 
.................... #define RF_PACKET1_DCFREE_WHITENING   0x40 
....................  
.................... #define RF_PACKET1_CRC_ON             0x10  // Default 
.................... #define RF_PACKET1_CRC_OFF            0x00 
....................  
.................... #define RF_PACKET1_CRCAUTOCLEAR_ON    0x00  // Default 
.................... #define RF_PACKET1_CRCAUTOCLEAR_OFF   0x08 
....................  
.................... #define RF_PACKET1_ADRSFILTERING_OFF            0x00  // Default 
.................... #define RF_PACKET1_ADRSFILTERING_NODE           0x02 
.................... #define RF_PACKET1_ADRSFILTERING_NODEBROADCAST  0x04 
....................  
....................  
.................... // RegPayloadLength 
.................... #define RF_PAYLOADLENGTH_VALUE          0x40  // Default 
....................  
....................  
.................... // RegBroadcastAdrs 
.................... #define RF_BROADCASTADDRESS_VALUE       0x00 
....................  
....................  
.................... // RegAutoModes 
.................... #define RF_AUTOMODES_ENTER_OFF                0x00  // Default 
.................... #define RF_AUTOMODES_ENTER_FIFONOTEMPTY       0x20 
.................... #define RF_AUTOMODES_ENTER_FIFOLEVEL          0x40 
.................... #define RF_AUTOMODES_ENTER_CRCOK              0x60 
.................... #define RF_AUTOMODES_ENTER_PAYLOADREADY       0x80 
.................... #define RF_AUTOMODES_ENTER_SYNCADRSMATCH      0xA0 
.................... #define RF_AUTOMODES_ENTER_PACKETSENT         0xC0 
.................... #define RF_AUTOMODES_ENTER_FIFOEMPTY          0xE0 
....................  
.................... #define RF_AUTOMODES_EXIT_OFF                 0x00  // Default 
.................... #define RF_AUTOMODES_EXIT_FIFOEMPTY           0x04 
.................... #define RF_AUTOMODES_EXIT_FIFOLEVEL           0x08 
.................... #define RF_AUTOMODES_EXIT_CRCOK               0x0C 
.................... #define RF_AUTOMODES_EXIT_PAYLOADREADY        0x10 
.................... #define RF_AUTOMODES_EXIT_SYNCADRSMATCH       0x14 
.................... #define RF_AUTOMODES_EXIT_PACKETSENT          0x18 
.................... #define RF_AUTOMODES_EXIT_RXTIMEOUT           0x1C 
....................  
.................... #define RF_AUTOMODES_INTERMEDIATE_SLEEP       0x00  // Default 
.................... #define RF_AUTOMODES_INTERMEDIATE_STANDBY     0x01 
.................... #define RF_AUTOMODES_INTERMEDIATE_RECEIVER    0x02 
.................... #define RF_AUTOMODES_INTERMEDIATE_TRANSMITTER 0x03 
....................  
....................  
.................... // RegFifoThresh 
.................... #define RF_FIFOTHRESH_TXSTART_FIFOTHRESH      0x00  // Reset value 
.................... #define RF_FIFOTHRESH_TXSTART_FIFONOTEMPTY    0x80  // Recommended default 
....................  
.................... #define RF_FIFOTHRESH_VALUE                   0x0F  // Default 
....................  
....................  
.................... // RegPacketConfig2 
.................... #define RF_PACKET2_RXRESTARTDELAY_1BIT        0x00  // Default 
.................... #define RF_PACKET2_RXRESTARTDELAY_2BITS       0x10 
.................... #define RF_PACKET2_RXRESTARTDELAY_4BITS       0x20 
.................... #define RF_PACKET2_RXRESTARTDELAY_8BITS       0x30 
.................... #define RF_PACKET2_RXRESTARTDELAY_16BITS      0x40 
.................... #define RF_PACKET2_RXRESTARTDELAY_32BITS      0x50 
.................... #define RF_PACKET2_RXRESTARTDELAY_64BITS      0x60 
.................... #define RF_PACKET2_RXRESTARTDELAY_128BITS     0x70 
.................... #define RF_PACKET2_RXRESTARTDELAY_256BITS     0x80 
.................... #define RF_PACKET2_RXRESTARTDELAY_512BITS     0x90 
.................... #define RF_PACKET2_RXRESTARTDELAY_1024BITS    0xA0 
.................... #define RF_PACKET2_RXRESTARTDELAY_2048BITS    0xB0 
.................... #define RF_PACKET2_RXRESTARTDELAY_NONE        0xC0 
.................... #define RF_PACKET2_RXRESTART                  0x04 
....................  
.................... #define RF_PACKET2_AUTORXRESTART_ON           0x02  // Default 
.................... #define RF_PACKET2_AUTORXRESTART_OFF          0x00 
....................  
.................... #define RF_PACKET2_AES_ON                     0x01 
.................... #define RF_PACKET2_AES_OFF                    0x00  // Default 
....................  
....................  
.................... // RegAesKey1-16 
.................... #define RF_AESKEY1_VALUE            0x00  // Default 
.................... #define RF_AESKEY2_VALUE            0x00  // Default 
.................... #define RF_AESKEY3_VALUE            0x00  // Default 
.................... #define RF_AESKEY4_VALUE            0x00  // Default 
.................... #define RF_AESKEY5_VALUE            0x00  // Default 
.................... #define RF_AESKEY6_VALUE            0x00  // Default 
.................... #define RF_AESKEY7_VALUE            0x00  // Default 
.................... #define RF_AESKEY8_VALUE            0x00  // Default 
.................... #define RF_AESKEY9_VALUE            0x00  // Default 
.................... #define RF_AESKEY10_VALUE           0x00  // Default 
.................... #define RF_AESKEY11_VALUE           0x00  // Default 
.................... #define RF_AESKEY12_VALUE           0x00  // Default 
.................... #define RF_AESKEY13_VALUE           0x00  // Default 
.................... #define RF_AESKEY14_VALUE           0x00  // Default 
.................... #define RF_AESKEY15_VALUE           0x00  // Default 
.................... #define RF_AESKEY16_VALUE           0x00  // Default 
....................  
....................  
.................... // RegTemp1 
.................... #define RF_TEMP1_MEAS_START         0x08 
.................... #define RF_TEMP1_MEAS_RUNNING       0x04 
.................... // not present on RFM69/SX1231 
.................... #define RF_TEMP1_ADCLOWPOWER_ON     0x01  // Default 
.................... #define RF_TEMP1_ADCLOWPOWER_OFF    0x00 
....................  
....................  
.................... // RegTestLna 
.................... #define RF_TESTLNA_NORMAL           0x1B 
.................... #define RF_TESTLNA_HIGH_SENSITIVITY 0x2D 
....................  
....................  
.................... // RegTestDagc 
.................... #define RF_DAGC_NORMAL              0x00  // Reset value 
.................... #define RF_DAGC_IMPROVED_LOWBETA1   0x20 
.................... #define RF_DAGC_IMPROVED_LOWBETA0   0x30  // Recommended default 
....................  
....................  
.................... #define RF69_MAX_DATA_LEN       61  
.................... int CSMA_LIMIT = -90; // upper RX signal sensitivity threshold in dBm for carrier sense access 
.................... #define RF69_MODE_SLEEP         0 // XTAL OFF 
.................... #define RF69_MODE_STANDBY       1 // XTAL ON 
.................... #define RF69_MODE_SYNTH         2 // PLL ON 
.................... #define RF69_MODE_RX            3 // RX MODE 
.................... #define RF69_MODE_TX            4 // TX MODE 
....................  
.................... // available frequency bands 
.................... #define RF69_315MHZ            31 // non trivial values to avoid misconfiguration 
.................... #define RF69_433MHZ            43 
.................... #define RF69_868MHZ            86 
.................... #define RF69_915MHZ            91 
....................  
.................... #define COURSE_TEMP_COEF    -90 // puts the temperature reading in the ballpark, user can fine tune the returned value 
.................... #define RF69_BROADCAST_ADDR 255 
.................... #define RF69_CSMA_LIMIT_MS 1000 
.................... #define RF69_TX_LIMIT_MS   1000 
.................... #define RF69_FSTEP  61.03515625 // == FXOSC / 2^19 = 32MHz / 2^19 (p13 in datasheet) 
....................  
.................... // TWS: define CTLbyte bits 
.................... #define RFM69_CTL_SENDACK   0x80 
.................... #define RFM69_CTL_REQACK    0x40 
....................  
....................    // static volatile int DATA[RF69_MAX_DATA_LEN]; // recv/xmit buf, including header & crc bytes 
....................     //static volatile int DATALEN; 
....................     //static volatile int SENDERID; 
....................     //static volatile int TARGETID; // should match _address 
....................     static volatile int PAYLOADLEN; 
....................     //static volatile int ACK_REQUESTED; 
....................     //static volatile int ACK_RECEIVED; // should be polled immediately after sending a packet with ACK request 
....................     static volatile int16 RSSI; // most accurate RSSI during reception (closest to the reception) 
....................     static volatile int _mode, _address;// should be protected? 
....................     short  _isRFM69HW=1; 
....................     //short  _promiscuousMode = 0; 
....................     int    _powerLevel = 31; 
....................  
....................     byte SPIRead8bit(void); 
....................     byte SPItransfer(byte WrPara); 
....................     int32 millis(); 
....................     short initialize(int8 ID); 
....................     short canSend(); 
....................     void send(int toAddress,byte* buffer, int bufferSize, short requestACK=false); 
....................     short sendWithRetry(int toAddress, byte* buffer, int bufferSize, int retries=2, int retryWaitTime=40); // 40ms roundtrip req for 61byte packets 
....................     short receiveDone(); 
....................     short ACKReceived(int fromNodeID); 
....................     short ACKRequested(); 
....................     void sendACK(byte* buffer , int bufferSize); 
....................  
....................     // allow hacking registers by making these public 
....................     int readReg(int addr); 
....................     void writeReg(int8 addr, int8 val); 
....................     void readAllRegs(); 
....................      
....................     //static volatile short _inISR; 
....................     void sendFrame(int8 toAddress, byte *buffer, int size, short requestACK=false,short sendACK=false); 
....................  
....................     void setMode(int mode); 
....................     void select(); 
....................     void unselect(); 
....................     int16 readRSSI(short forceTrigger); 
....................     void setHighPower(short onOff); 
....................     void setHighPowerRegs(short onOff); 
....................  
.................... short initialize( int nodeID) 
.................... { 
....................    const int networkID = 1; 
....................  
....................   const int8 CONFIG[][2] = 
....................   { 
....................     /* 0x01 */ { REG_OPMODE, RF_OPMODE_SEQUENCER_ON | RF_OPMODE_LISTEN_OFF | RF_OPMODE_STANDBY }, 
....................     /* 0x02 */ { REG_DATAMODUL, RF_DATAMODUL_DATAMODE_PACKET | RF_DATAMODUL_MODULATIONTYPE_FSK | RF_DATAMODUL_MODULATIONSHAPING_00 }, // no shaping 
....................     /* 0x03 */ { REG_BITRATEMSB, RF_BITRATEMSB_55555}, // default: 4.8 KBPS 
....................     /* 0x04 */ { REG_BITRATELSB, RF_BITRATELSB_55555}, 
....................     /* 0x05 */ { REG_FDEVMSB, RF_FDEVMSB_50000}, // default: 5KHz, (FDEV + BitRate / 2 <= 500KHz) 
....................     /* 0x06 */ { REG_FDEVLSB, RF_FDEVLSB_50000}, 
....................  
....................     /* 0x07 */ { REG_FRFMSB, RF_FRFMSB_915 }, 
....................     /* 0x08 */ { REG_FRFMID, RF_FRFMID_915 }, 
....................     /* 0x09 */ { REG_FRFLSB, RF_FRFLSB_915 }, 
....................  
....................     // looks like PA1 and PA2 are not implemented on RFM69W, hence the max output power is 13dBm 
....................     // +17dBm and +20dBm are possible on RFM69HW 
....................     // +13dBm formula: Pout = -18 + OutputPower (with PA0 or PA1**) 
....................     // +17dBm formula: Pout = -14 + OutputPower (with PA1 and PA2)** 
....................     // +20dBm formula: Pout = -11 + OutputPower (with PA1 and PA2)** and high power PA settings (section 3.3.7 in datasheet) 
....................     ///* 0x11 */ { REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | RF_PALEVEL_OUTPUTPOWER_11111}, 
....................     ///* 0x13 */ { REG_OCP, RF_OCP_ON | RF_OCP_TRIM_95 }, // over current protection (default is 95mA) 
....................  
....................     // RXBW defaults are { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_24 | RF_RXBW_EXP_5} (RxBw: 10.4KHz) 
....................     /* 0x19 */ { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_16 | RF_RXBW_EXP_2 }, // (BitRate < 2 * RxBw) 
....................     //for BR-19200: /* 0x19 */ { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_24 | RF_RXBW_EXP_3 }, 
....................     /* 0x25 */ { REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_01 }, // DIO0 is the only IRQ we're using 
....................     /* 0x26 */ { REG_DIOMAPPING2, RF_DIOMAPPING2_CLKOUT_OFF }, // DIO5 ClkOut disable for power saving 
....................     /* 0x28 */ { REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN }, // writing to this bit ensures that the FIFO & status flags are reset 
....................     /* 0x29 */ { REG_RSSITHRESH, 220 }, // must be set to dBm = (-Sensitivity / 2), default is 0xE4 = 228 so -114dBm 
....................     /* 0x2D */ { REG_PREAMBLELSB, RF_PREAMBLESIZE_LSB_VALUE }, // default 3 preamble bytes 0xAAAAAA 
....................     /* 0x2E */ { REG_SYNCCONFIG, RF_SYNC_ON | RF_SYNC_FIFOFILL_AUTO | RF_SYNC_SIZE_2 | RF_SYNC_TOL_0 }, 
....................     /* 0x2F */ { REG_SYNCVALUE1, 0x2D },      // attempt to make this compatible with sync1 byte of RFM12B lib 
....................     /* 0x30 */ { REG_SYNCVALUE2, networkID}, // NETWORK ID 
....................     /* 0x37 */ { REG_PACKETCONFIG1, RF_PACKET1_FORMAT_VARIABLE | RF_PACKET1_DCFREE_OFF | RF_PACKET1_CRC_ON | RF_PACKET1_CRCAUTOCLEAR_ON | RF_PACKET1_ADRSFILTERING_OFF }, 
....................     /* 0x38 */ { REG_PAYLOADLENGTH, 66 }, // in variable length mode: the max frame size, not used in TX 
....................     ///* 0x39 */ { REG_NODEADRS, nodeID }, // turned off because we're not using address filtering 
....................     /* 0x3C */ { REG_FIFOTHRESH, RF_FIFOTHRESH_TXSTART_FIFONOTEMPTY | RF_FIFOTHRESH_VALUE }, // TX on FIFO not empty 
....................     /* 0x3D */ { REG_PACKETCONFIG2, RF_PACKET2_RXRESTARTDELAY_2BITS | RF_PACKET2_AUTORXRESTART_ON | RF_PACKET2_AES_OFF }, // RXRESTARTDELAY must match transmitter PA ramp-down time (bitrate dependent) 
....................     //for BR-19200: /* 0x3D */ { REG_PACKETCONFIG2, RF_PACKET2_RXRESTARTDELAY_NONE | RF_PACKET2_AUTORXRESTART_ON | RF_PACKET2_AES_OFF }, // RXRESTARTDELAY must match transmitter PA ramp-down time (bitrate dependent) 
....................     /* 0x6F */ { REG_TESTDAGC, RF_DAGC_IMPROVED_LOWBETA0 }, // run DAGC continuously in RX mode for Fading Margin Improvement, recommended default for AfcLowBetaOn=0 
....................     {255, 0} 
....................   }; 
....................     
....................   // printf("sincronizando"); 
....................   output_high(_slaveSelectPin); 
*
0492:  BCF    F95.7
0494:  BSF    F8C.7
....................   int32 start = millis(); 
....................   int timeout = 50; 
0496:  RCALL  0004
0498:  MOVFF  03,F3
049C:  MOVFF  02,F2
04A0:  MOVFF  01,F1
04A4:  MOVFF  00,F0
04A8:  MOVLW  32
04AA:  MOVWF  xF4
....................   do writeReg(REG_SYNCVALUE1, 0xAA); while (readReg(REG_SYNCVALUE1) != 0xaa && millis()-start < timeout); 
04AC:  MOVLW  2F
04AE:  MOVLB  1
04B0:  MOVWF  x07
04B2:  MOVLW  AA
04B4:  MOVWF  x08
04B6:  MOVLB  0
04B8:  RCALL  027E
04BA:  MOVLW  2F
04BC:  MOVLB  1
04BE:  MOVWF  x05
04C0:  MOVLB  0
04C2:  RCALL  02D2
04C4:  MOVF   01,W
04C6:  SUBLW  AA
04C8:  BZ    04FC
04CA:  RCALL  0004
04CC:  MOVFF  03,F9
04D0:  MOVFF  02,F8
04D4:  MOVFF  01,F7
04D8:  MOVFF  00,F6
04DC:  MOVF   xF0,W
04DE:  SUBWF  xF6,F
04E0:  MOVF   xF1,W
04E2:  SUBWFB xF7,F
04E4:  MOVF   xF2,W
04E6:  SUBWFB xF8,F
04E8:  MOVF   xF3,W
04EA:  SUBWFB xF9,F
04EC:  BNZ   04FC
04EE:  MOVF   xF8,F
04F0:  BNZ   04FC
04F2:  MOVF   xF7,F
04F4:  BNZ   04FC
04F6:  MOVF   xF4,W
04F8:  SUBWF  xF6,W
04FA:  BNC   04AC
....................   //printf("sincronizado1"); 
....................   start = millis(); 
04FC:  RCALL  0004
04FE:  MOVFF  03,F3
0502:  MOVFF  02,F2
0506:  MOVFF  01,F1
050A:  MOVFF  00,F0
....................   do writeReg(REG_SYNCVALUE1, 0x55); while (readReg(REG_SYNCVALUE1) != 0x55 && millis()-start < timeout); 
050E:  MOVLW  2F
0510:  MOVLB  1
0512:  MOVWF  x07
0514:  MOVLW  55
0516:  MOVWF  x08
0518:  MOVLB  0
051A:  RCALL  027E
051C:  MOVLW  2F
051E:  MOVLB  1
0520:  MOVWF  x05
0522:  MOVLB  0
0524:  RCALL  02D2
0526:  MOVF   01,W
0528:  SUBLW  55
052A:  BZ    055E
052C:  RCALL  0004
052E:  MOVFF  03,F9
0532:  MOVFF  02,F8
0536:  MOVFF  01,F7
053A:  MOVFF  00,F6
053E:  MOVF   xF0,W
0540:  SUBWF  xF6,F
0542:  MOVF   xF1,W
0544:  SUBWFB xF7,F
0546:  MOVF   xF2,W
0548:  SUBWFB xF8,F
054A:  MOVF   xF3,W
054C:  SUBWFB xF9,F
054E:  BNZ   055E
0550:  MOVF   xF8,F
0552:  BNZ   055E
0554:  MOVF   xF7,F
0556:  BNZ   055E
0558:  MOVF   xF4,W
055A:  SUBWF  xF6,W
055C:  BNC   050E
....................   //printf("sincronizado2"); 
....................    
....................   for (int i = 0; CONFIG[i][0] != 255; i++) 
055E:  CLRF   xF5
0560:  BCF    FD8.0
0562:  RLCF   xF5,W
0564:  CLRF   xF7
0566:  MOVWF  xF6
0568:  MOVFF  F7,03
056C:  MOVF   xF6,W
056E:  RCALL  00BA
0570:  SUBLW  FF
0572:  BZ    05AE
....................     writeReg(CONFIG[i][0], CONFIG[i][1]); 
0574:  BCF    FD8.0
0576:  RLCF   xF5,W
0578:  CLRF   xF7
057A:  MOVWF  xF6
057C:  MOVFF  F7,03
0580:  MOVF   xF6,W
0582:  RCALL  00BA
0584:  MOVWF  xF8
0586:  BCF    FD8.0
0588:  RLCF   xF5,W
058A:  CLRF   xFA
058C:  MOVWF  xF9
058E:  MOVLW  01
0590:  ADDWF  xF9,W
0592:  MOVWF  01
0594:  MOVLW  00
0596:  ADDWFC xFA,W
0598:  MOVWF  03
059A:  MOVF   01,W
059C:  RCALL  00BA
059E:  MOVWF  xF9
05A0:  MOVFF  F8,107
05A4:  MOVFF  FE8,108
05A8:  RCALL  027E
05AA:  INCF   xF5,F
05AC:  BRA    0560
....................  
....................     
....................   // Encryption is persistent between resets and can trip you up during debugging. 
....................   // Disable it during initialization so we always start from a known state. 
....................    
....................   setHighPower(_isRFM69HW); // called regardless if it's a RFM69W or RFM69HW 
05AE:  MOVLW  00
05B0:  BTFSC  2A.0
05B2:  MOVLW  01
05B4:  MOVWF  xF6
05B6:  MOVWF  xF7
05B8:  RCALL  02F4
....................   setMode(RF69_MODE_STANDBY); 
05BA:  MOVLW  01
05BC:  MOVLB  1
05BE:  MOVWF  x04
05C0:  MOVLB  0
05C2:  RCALL  0388
....................   start = millis(); 
05C4:  RCALL  0004
05C6:  MOVFF  03,F3
05CA:  MOVFF  02,F2
05CE:  MOVFF  01,F1
05D2:  MOVFF  00,F0
....................   while (((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00) && millis()-start < timeout); // wait for ModeReady 
05D6:  MOVLW  27
05D8:  MOVLB  1
05DA:  MOVWF  x05
05DC:  MOVLB  0
05DE:  RCALL  02D2
05E0:  MOVF   01,W
05E2:  ANDLW  80
05E4:  BNZ   0618
05E6:  RCALL  0004
05E8:  MOVFF  03,F9
05EC:  MOVFF  02,F8
05F0:  MOVFF  01,F7
05F4:  MOVFF  00,F6
05F8:  MOVF   xF0,W
05FA:  SUBWF  xF6,F
05FC:  MOVF   xF1,W
05FE:  SUBWFB xF7,F
0600:  MOVF   xF2,W
0602:  SUBWFB xF8,F
0604:  MOVF   xF3,W
0606:  SUBWFB xF9,F
0608:  BNZ   0618
060A:  MOVF   xF8,F
060C:  BNZ   0618
060E:  MOVF   xF7,F
0610:  BNZ   0618
0612:  MOVF   xF4,W
0614:  SUBWF  xF6,W
0616:  BNC   05D6
....................   if (millis()-start >= timeout) 
0618:  RCALL  0004
061A:  MOVFF  03,F9
061E:  MOVFF  02,F8
0622:  MOVFF  01,F7
0626:  MOVFF  00,F6
062A:  MOVF   xF0,W
062C:  SUBWF  xF6,F
062E:  MOVF   xF1,W
0630:  SUBWFB xF7,F
0632:  MOVF   xF2,W
0634:  SUBWFB xF8,F
0636:  MOVF   xF3,W
0638:  SUBWFB xF9,F
063A:  BNZ   064A
063C:  MOVF   xF8,F
063E:  BNZ   064A
0640:  MOVF   xF7,F
0642:  BNZ   064A
0644:  MOVF   xF4,W
0646:  SUBWF  xF6,W
0648:  BNC   0650
....................     return false; 
064A:  MOVLW  00
064C:  MOVWF  01
064E:  BRA    0658
....................    
....................   //_inISR = false; 
....................     //ext_int_edge(L_TO_H); 
....................    //Enable_interrupts(INT_EXT); 
....................  
....................  //printf("configurado"); 
....................   _address = nodeID; 
0650:  MOVFF  EF,29
....................   return true; 
0654:  MOVLW  01
0656:  MOVWF  01
0658:  GOTO   09D4 (RETURN)
.................... } 
....................  
....................  
.................... void setMode(int newMode) 
.................... { 
....................    
....................    if (newMode == _mode) 
*
0388:  MOVF   28,W
038A:  MOVLB  1
038C:  SUBWF  x04,W
038E:  BNZ   0392
....................     return; 
0390:  BRA    048E
....................  
....................   switch (newMode) { 
0392:  MOVF   x04,W
0394:  XORLW  04
0396:  MOVLB  0
0398:  BZ    03AC
039A:  XORLW  07
039C:  BZ    03DC
039E:  XORLW  01
03A0:  BZ    040A
03A2:  XORLW  03
03A4:  BZ    042C
03A6:  XORLW  01
03A8:  BZ    044E
03AA:  BRA    046E
....................     case RF69_MODE_TX: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_TRANSMITTER); 
03AC:  MOVLW  01
03AE:  MOVLB  1
03B0:  MOVWF  x05
03B2:  MOVLB  0
03B4:  RCALL  02D2
03B6:  MOVF   01,W
03B8:  ANDLW  E3
03BA:  IORLW  0C
03BC:  MOVLB  1
03BE:  MOVWF  x05
03C0:  MOVLW  01
03C2:  MOVWF  x07
03C4:  MOVFF  105,108
03C8:  MOVLB  0
03CA:  RCALL  027E
....................       if (_isRFM69HW) setHighPowerRegs(true); 
03CC:  BTFSS  2A.0
03CE:  BRA    03DA
03D0:  MOVLW  01
03D2:  MOVLB  1
03D4:  MOVWF  x05
03D6:  MOVLB  0
03D8:  RCALL  0352
....................       break; 
03DA:  BRA    0474
....................     case RF69_MODE_RX: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_RECEIVER); 
03DC:  MOVLW  01
03DE:  MOVLB  1
03E0:  MOVWF  x05
03E2:  MOVLB  0
03E4:  RCALL  02D2
03E6:  MOVF   01,W
03E8:  ANDLW  E3
03EA:  IORLW  10
03EC:  MOVLB  1
03EE:  MOVWF  x05
03F0:  MOVLW  01
03F2:  MOVWF  x07
03F4:  MOVFF  105,108
03F8:  MOVLB  0
03FA:  RCALL  027E
....................       if (_isRFM69HW) setHighPowerRegs(false); 
03FC:  BTFSS  2A.0
03FE:  BRA    0408
0400:  MOVLB  1
0402:  CLRF   x05
0404:  MOVLB  0
0406:  RCALL  0352
....................       break; 
0408:  BRA    0474
....................     case RF69_MODE_SYNTH: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SYNTHESIZER); 
040A:  MOVLW  01
040C:  MOVLB  1
040E:  MOVWF  x05
0410:  MOVLB  0
0412:  RCALL  02D2
0414:  MOVF   01,W
0416:  ANDLW  E3
0418:  IORLW  08
041A:  MOVLB  1
041C:  MOVWF  x05
041E:  MOVLW  01
0420:  MOVWF  x07
0422:  MOVFF  105,108
0426:  MOVLB  0
0428:  RCALL  027E
....................       break; 
042A:  BRA    0474
....................     case RF69_MODE_STANDBY: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_STANDBY); 
042C:  MOVLW  01
042E:  MOVLB  1
0430:  MOVWF  x05
0432:  MOVLB  0
0434:  RCALL  02D2
0436:  MOVF   01,W
0438:  ANDLW  E3
043A:  IORLW  04
043C:  MOVLB  1
043E:  MOVWF  x05
0440:  MOVLW  01
0442:  MOVWF  x07
0444:  MOVFF  105,108
0448:  MOVLB  0
044A:  RCALL  027E
....................       break; 
044C:  BRA    0474
....................     case RF69_MODE_SLEEP: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SLEEP); 
044E:  MOVLW  01
0450:  MOVLB  1
0452:  MOVWF  x05
0454:  MOVLB  0
0456:  RCALL  02D2
0458:  MOVF   01,W
045A:  ANDLW  E3
045C:  MOVLB  1
045E:  MOVWF  x05
0460:  MOVLW  01
0462:  MOVWF  x07
0464:  MOVFF  105,108
0468:  MOVLB  0
046A:  RCALL  027E
....................       break; 
046C:  BRA    0474
....................     default: 
....................       return; 
046E:  MOVLB  1
0470:  BRA    048E
0472:  MOVLB  0
....................   } 
....................  
....................   // we are using packet mode, so this check is not really needed 
....................   // but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode 
....................   while (_mode == RF69_MODE_SLEEP && (readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady 
0474:  MOVF   28,F
0476:  BNZ   0488
0478:  MOVLW  27
047A:  MOVLB  1
047C:  MOVWF  x05
047E:  MOVLB  0
0480:  RCALL  02D2
0482:  MOVF   01,W
0484:  ANDLW  80
0486:  BZ    0474
....................  
....................   _mode = newMode; 
0488:  MOVFF  104,28
048C:  MOVLB  1
048E:  MOVLB  0
0490:  RETURN 0
.................... } 
....................  
.................... short canSend() 
.................... { 
.................... if ((_mode == RF69_MODE_RX) && (PAYLOADLEN == 0) && (readRSSI(1) < CSMA_LIMIT)) // if signal stronger than -100dBm is detected assume channel activity 
*
0752:  MOVF   28,W
0754:  SUBLW  03
0756:  BNZ   0784
0758:  MOVF   25,F
075A:  BNZ   0784
075C:  MOVLW  01
075E:  MOVWF  xF8
0760:  BRA    0706
0762:  MOVFF  02,F9
0766:  MOVFF  01,F8
076A:  MOVF   xF9,F
076C:  BNZ   0784
076E:  MOVF   24,W
0770:  SUBWF  xF8,W
0772:  BC    0784
....................   { 
....................     setMode(RF69_MODE_STANDBY); 
0774:  MOVLW  01
0776:  MOVLB  1
0778:  MOVWF  x04
077A:  MOVLB  0
077C:  RCALL  0388
....................     return true; 
077E:  MOVLW  01
0780:  MOVWF  01
0782:  BRA    0788
....................   } 
....................   return false; 
0784:  MOVLW  00
0786:  MOVWF  01
0788:  GOTO   08EC (RETURN)
.................... } 
....................  
.................... void send(int toAddress, byte * buffer, int bufferSize, short requestACK) 
.................... { 
....................   writeReg(REG_PACKETCONFIG2, (readReg(REG_PACKETCONFIG2) & 0xFB) | RF_PACKET2_RXRESTART); // avoid RX deadlocks 
*
08B6:  MOVLW  3D
08B8:  MOVLB  1
08BA:  MOVWF  x05
08BC:  MOVLB  0
08BE:  RCALL  02D2
08C0:  MOVF   01,W
08C2:  ANDLW  FB
08C4:  IORLW  04
08C6:  MOVWF  xF8
08C8:  MOVLW  3D
08CA:  MOVLB  1
08CC:  MOVWF  x07
08CE:  MOVFF  F8,108
08D2:  MOVLB  0
08D4:  RCALL  027E
....................   int32 now = millis(); 
08D6:  CALL   01EA
08DA:  MOVFF  03,F7
08DE:  MOVFF  02,F6
08E2:  MOVFF  01,F5
08E6:  MOVFF  00,F4
....................   while (!canSend() && millis() - now < RF69_CSMA_LIMIT_MS); 
08EA:  BRA    0752
08EC:  MOVF   01,F
08EE:  BNZ   0928
08F0:  CALL   01EA
08F4:  MOVFF  03,FB
08F8:  MOVFF  02,FA
08FC:  MOVFF  01,F9
0900:  MOVFF  00,F8
0904:  MOVF   xF4,W
0906:  SUBWF  xF8,F
0908:  MOVF   xF5,W
090A:  SUBWFB xF9,F
090C:  MOVF   xF6,W
090E:  SUBWFB xFA,F
0910:  MOVF   xF7,W
0912:  SUBWFB xFB,F
0914:  BNZ   0928
0916:  MOVF   xFA,F
0918:  BNZ   0928
091A:  MOVF   xF9,W
091C:  SUBLW  03
091E:  BNC   0928
0920:  BNZ   08EA
0922:  MOVF   xF8,W
0924:  SUBLW  E7
0926:  BC    08EA
....................   sendFrame(toAddress, buffer, bufferSize, requestACK, false); 
0928:  MOVFF  EF,F8
092C:  MOVFF  F1,FA
0930:  MOVFF  F0,F9
0934:  MOVFF  F2,FB
0938:  MOVFF  F3,FC
093C:  CLRF   xFD
093E:  BRA    078C
0940:  GOTO   0A22 (RETURN)
.................... } 
....................  
.................... // to increase the chance of getting a packet across, call this function instead of send 
.................... // and it handles all the ACK requesting/retrying for you :) 
.................... // The only twist is that you have to manually listen to ACK requests on the other side and send back the ACKs 
.................... // The reason for the semi-automaton is that the lib is interrupt driven and 
.................... // requires user action to read the received data and decide what to do with it 
.................... // replies usually take only 5..8ms at 50kbps@915MHz 
.................... short sendWithRetry(int toAddress, byte *buffer, int bufferSize, int retries, int retryWaitTime) { 
....................   int32 sentTime; 
....................   for (int i = 0; i <= retries; i++) 
....................   { 
....................     send(toAddress, buffer, bufferSize, true); 
....................     sentTime = millis(); 
....................     while (millis() - sentTime < retryWaitTime); 
....................     
....................   } 
....................   return false; 
.................... } 
....................  
....................  
.................... // internal function 
.................... void sendFrame(int toAddress, byte *buffer, int bufferSize, short requestACK, short sendACK) 
.................... { 
....................   setMode(RF69_MODE_STANDBY); // turn off receiver to prevent reception while filling fifo 
*
078C:  MOVLW  01
078E:  MOVLB  1
0790:  MOVWF  x04
0792:  MOVLB  0
0794:  RCALL  0388
....................   while ((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady 
0796:  MOVLW  27
0798:  MOVLB  1
079A:  MOVWF  x05
079C:  MOVLB  0
079E:  RCALL  02D2
07A0:  MOVF   01,W
07A2:  ANDLW  80
07A4:  BZ    0796
....................   writeReg(REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_00); // DIO0 is "Packet Sent" 
07A6:  MOVLW  25
07A8:  MOVLB  1
07AA:  MOVWF  x07
07AC:  CLRF   x08
07AE:  MOVLB  0
07B0:  RCALL  027E
....................   if (bufferSize > RF69_MAX_DATA_LEN) bufferSize = RF69_MAX_DATA_LEN; 
07B2:  MOVF   xFB,W
07B4:  SUBLW  3D
07B6:  BC    07BC
07B8:  MOVLW  3D
07BA:  MOVWF  xFB
....................  
....................   // control byte 
....................   byte CTLbyte = 0x00; 
07BC:  CLRF   xFE
....................   if (sendACK) 
07BE:  MOVF   xFD,F
07C0:  BZ    07C8
....................     CTLbyte = RFM69_CTL_SENDACK; 
07C2:  MOVLW  80
07C4:  MOVWF  xFE
07C6:  BRA    07D0
....................   else if (requestACK) 
07C8:  MOVF   xFC,F
07CA:  BZ    07D0
....................     CTLbyte = RFM69_CTL_REQACK; 
07CC:  MOVLW  40
07CE:  MOVWF  xFE
....................  
....................   // write to FIFO 
....................   select(); 
07D0:  RCALL  022A
....................   SPItransfer(REG_FIFO | 0x80); 
07D2:  MOVLW  80
07D4:  MOVLB  1
07D6:  MOVWF  x0A
07D8:  MOVLB  0
07DA:  RCALL  0230
....................   SPItransfer(bufferSize + 3); 
07DC:  MOVLW  03
07DE:  ADDWF  xFB,W
07E0:  MOVLB  1
07E2:  MOVWF  x04
07E4:  MOVWF  x0A
07E6:  MOVLB  0
07E8:  RCALL  0230
....................   SPItransfer(toAddress); 
07EA:  MOVFF  F8,10A
07EE:  RCALL  0230
....................   SPItransfer(_address); 
07F0:  MOVFF  29,10A
07F4:  RCALL  0230
....................   SPItransfer(CTLbyte); 
07F6:  MOVFF  FE,10A
07FA:  RCALL  0230
....................  
....................   for (int i = 0; i < bufferSize; i++) 
07FC:  CLRF   xFF
07FE:  MOVF   xFB,W
0800:  SUBWF  xFF,W
0802:  BC    081A
....................     SPItransfer(((byte *) buffer)[i]); 
0804:  MOVF   xFF,W
0806:  ADDWF  xF9,W
0808:  MOVWF  FE9
080A:  MOVLW  00
080C:  ADDWFC xFA,W
080E:  MOVWF  FEA
0810:  MOVFF  FEF,10A
0814:  RCALL  0230
0816:  INCF   xFF,F
0818:  BRA    07FE
....................   unselect(); 
081A:  RCALL  0278
....................  
....................   // no need to wait for transmit mode to be ready since its handled by the radio 
....................   setMode(RF69_MODE_TX); 
081C:  MOVLW  04
081E:  MOVLB  1
0820:  MOVWF  x04
0822:  MOVLB  0
0824:  RCALL  0388
....................   int32 txStart = millis(); 
0826:  CALL   01EA
082A:  MOVFF  03,103
082E:  MOVFF  02,102
0832:  MOVFF  01,101
0836:  MOVFF  00,100
....................   while ( input(_interruptPin) == 0 && millis() - txStart < RF69_TX_LIMIT_MS); // wait for DIO0 to turn HIGH signalling transmission finish 
083A:  BSF    F93.0
083C:  BTFSC  F81.0
083E:  BRA    089A
0840:  CALL   01EA
0844:  MOVFF  03,108
0848:  MOVFF  02,107
084C:  MOVFF  01,106
0850:  MOVFF  00,105
0854:  MOVLB  1
0856:  MOVF   x00,W
0858:  SUBWF  x05,F
085A:  MOVF   x01,W
085C:  SUBWFB x06,F
085E:  MOVF   x02,W
0860:  SUBWFB x07,F
0862:  MOVF   x03,W
0864:  SUBWFB x08,F
0866:  BTFSC  FD8.2
0868:  BRA    086E
086A:  MOVLB  0
086C:  BRA    089A
086E:  MOVF   x07,F
0870:  BTFSC  FD8.2
0872:  BRA    0878
0874:  MOVLB  0
0876:  BRA    089A
0878:  MOVF   x06,W
087A:  SUBLW  03
087C:  BTFSC  FD8.0
087E:  BRA    0884
0880:  MOVLB  0
0882:  BRA    089A
0884:  BTFSC  FD8.2
0886:  BRA    088C
0888:  MOVLB  0
088A:  BRA    083A
088C:  MOVF   x05,W
088E:  SUBLW  E7
0890:  BTFSS  FD8.0
0892:  BRA    0898
0894:  MOVLB  0
0896:  BRA    083A
0898:  MOVLB  0
....................   while (readReg(REG_IRQFLAGS2) & (RF_IRQFLAGS2_PACKETSENT == 0x00)); // wait for ModeReady 
089A:  MOVLW  28
089C:  MOVLB  1
089E:  MOVWF  x05
08A0:  MOVLB  0
08A2:  RCALL  02D2
08A4:  ANDLW  00
08A6:  BNZ   089A
....................   setMode(RF69_MODE_STANDBY); 
08A8:  MOVLW  01
08AA:  MOVLB  1
08AC:  MOVWF  x04
08AE:  MOVLB  0
08B0:  RCALL  0388
08B2:  GOTO   0940 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... int32 millis() 
.................... { 
....................    return get_ticks(); 
*
0004:  BRA    01EA
0006:  RETURN 0
.................... } 
....................  
.................... int readReg(int addr) 
.................... { 
....................   select(); 
*
02D2:  RCALL  022A
....................   SPItransfer(addr & 0x7F); 
02D4:  MOVLB  1
02D6:  MOVF   x05,W
02D8:  ANDLW  7F
02DA:  MOVWF  x07
02DC:  MOVWF  x0A
02DE:  MOVLB  0
02E0:  RCALL  0230
....................   int regval = SPIRead8bit(); 
02E2:  BRA    0298
02E4:  MOVFF  01,106
....................   unselect(); 
02E8:  RCALL  0278
....................   return regval; 
02EA:  MOVLB  1
02EC:  MOVFF  106,01
02F0:  MOVLB  0
02F2:  RETURN 0
.................... } 
....................  
.................... void writeReg(int addr, int value) 
.................... { 
....................   select(); 
*
027E:  RCALL  022A
....................   SPItransfer(addr | 0x80); 
0280:  MOVLB  1
0282:  MOVF   x07,W
0284:  IORLW  80
0286:  MOVWF  x09
0288:  MOVWF  x0A
028A:  MOVLB  0
028C:  RCALL  0230
....................   SPItransfer(value); 
028E:  MOVFF  108,10A
0292:  RCALL  0230
....................   unselect(); 
0294:  RCALL  0278
0296:  RETURN 0
.................... } 
....................  
.................... void select() { 
....................   output_low(_slaveSelectPin); 
*
022A:  BCF    F95.7
022C:  BCF    F8C.7
022E:  RETURN 0
.................... } 
....................  
.................... // unselect the RFM69 transceiver (set CS high, restore SPI settings) 
.................... void unselect() { 
....................   output_high(_slaveSelectPin); 
*
0278:  BCF    F95.7
027A:  BSF    F8C.7
027C:  RETURN 0
.................... } 
....................  
....................  
.................... // for RFM69HW only: you must call setHighPower(true) after initialize() or else transmission won't work 
.................... void setHighPower(short onOff) { 
....................   _isRFM69HW = onOff; 
*
02F4:  BCF    2A.0
02F6:  BTFSC  xF7.0
02F8:  BSF    2A.0
....................   writeReg(REG_OCP, _isRFM69HW ? RF_OCP_OFF : RF_OCP_ON); 
02FA:  BTFSS  2A.0
02FC:  BRA    0302
02FE:  MOVLW  0F
0300:  BRA    0304
0302:  MOVLW  1A
0304:  MOVWF  xF8
0306:  MOVLW  13
0308:  MOVLB  1
030A:  MOVWF  x07
030C:  MOVFF  F8,108
0310:  MOVLB  0
0312:  RCALL  027E
....................   if (_isRFM69HW) // turning ON 
0314:  BTFSS  2A.0
0316:  BRA    033C
....................     writeReg(REG_PALEVEL, (readReg(REG_PALEVEL) & 0x1F) | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON); // enable P1 & P2 amplifier stages 
0318:  MOVLW  11
031A:  MOVLB  1
031C:  MOVWF  x05
031E:  MOVLB  0
0320:  RCALL  02D2
0322:  MOVF   01,W
0324:  ANDLW  1F
0326:  IORLW  40
0328:  IORLW  20
032A:  MOVWF  xF8
032C:  MOVLW  11
032E:  MOVLB  1
0330:  MOVWF  x07
0332:  MOVFF  F8,108
0336:  MOVLB  0
0338:  RCALL  027E
033A:  BRA    0350
....................   else 
....................     writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | _powerLevel); // enable P0 only 
033C:  MOVF   2B,W
033E:  IORLW  80
0340:  MOVWF  xF8
0342:  MOVLW  11
0344:  MOVLB  1
0346:  MOVWF  x07
0348:  MOVFF  F8,108
034C:  MOVLB  0
034E:  RCALL  027E
0350:  RETURN 0
....................    //printf("HighPower"); 
.................... } 
....................  
....................  
....................  
.................... /*void readAllRegs() 
.................... { 
....................   int regVal; 
....................   
....................   //... State Variables for intelligent decoding 
....................    
....................   printf("Address - HEX - BIN \n"); 
....................   for (int regAddr = 1; regAddr <= 0x4F; regAddr++) 
....................   { 
....................     select(); 
....................     SPItransfer(regAddr & 0x7F); // send address + r/w bit 
....................     regVal = SPIRead8bit(); 
....................     unselect(); 
....................  
....................     printf("%X", regAddr); 
....................     printf(" - "); 
....................     printf("%X", regVal); 
....................     printf(" - "); 
....................     for (byte i = 8; i!=0 ; i--) 
....................       { 
....................       if(bit_test(regVal, (i-1)))  
....................          printf("1");  
....................       else  
....................          printf("0");  
....................       } 
....................      printf("\n"); 
....................     } 
....................   
....................   unselect(); 
.................... }*/ 
....................  
.................... byte SPItransfer(byte WrPara) 
*
0230:  MOVLB  1
0232:  CLRF   x0B
.................... { 
.................... byte Data_In = 0; 
.................... byte bitcnt;    
....................  
.................... Output_Low(SCK); 
0234:  BCF    F95.6
0236:  BCF    F8C.6
....................  for(bitcnt=8; bitcnt!=0; bitcnt--) 
0238:  MOVLW  08
023A:  MOVWF  x0C
023C:  MOVF   x0C,F
023E:  BZ    0268
....................     { 
....................     Output_Low(SCK); 
0240:  BCF    F95.6
0242:  BCF    F8C.6
....................     if(WrPara&0x80) 
0244:  BTFSS  x0A.7
0246:  BRA    024E
....................        Output_High(SerOut);   // RFM69 SDI  
0248:  BCF    F95.5
024A:  BSF    F8C.5
024C:  BRA    0252
....................     else 
....................        Output_Low(SerOut);    
024E:  BCF    F95.5
0250:  BCF    F8C.5
....................     Output_High(SCK); 
0252:  BCF    F95.6
0254:  BSF    F8C.6
....................     if (Input(SerIn)) 
0256:  BSF    F95.4
0258:  BTFSS  F83.4
025A:  BRA    025E
....................       Data_In |= 1; 
025C:  BSF    x0B.0
....................     WrPara <<= 1; 
025E:  BCF    FD8.0
0260:  RLCF   x0A,F
....................     delay_cycles(1); 
0262:  NOP   
0264:  DECF   x0C,F
0266:  BRA    023C
....................     } 
.................... Output_Low(SCK); 
0268:  BCF    F95.6
026A:  BCF    F8C.6
.................... Output_High(SerOut); 
026C:  BCF    F95.5
026E:  BSF    F8C.5
.................... return(Data_In); 
0270:  MOVFF  10B,01
0274:  MOVLB  0
0276:  RETURN 0
.................... } 
....................  
....................  
.................... byte SPIRead8bit(void) 
*
0298:  MOVLB  1
029A:  CLRF   x07
.................... { 
.................... byte RdPara = 0; 
.................... byte bitcnt; 
.................... Output_High(SerOut);   // RFM69 SDI                                                                          //Read one byte data from FIFO, MOSI hold to High  
029C:  BCF    F95.5
029E:  BSF    F8C.5
....................  for(bitcnt=8; bitcnt!=0; bitcnt--) 
02A0:  MOVLW  08
02A2:  MOVWF  x08
02A4:  MOVF   x08,F
02A6:  BZ    02C4
....................     { 
....................     Output_Low(SCK); 
02A8:  BCF    F95.6
02AA:  BCF    F8C.6
....................     RdPara <<= 1; 
02AC:  BCF    FD8.0
02AE:  RLCF   x07,F
....................     Output_High(SCK); 
02B0:  BCF    F95.6
02B2:  BSF    F8C.6
....................     if(Input(SerIn)) 
02B4:  BSF    F95.4
02B6:  BTFSS  F83.4
02B8:  BRA    02BE
....................        RdPara |= 0x01; 
02BA:  BSF    x07.0
02BC:  BRA    02C0
....................     else 
....................        delay_cycles(1);  
02BE:  NOP   
02C0:  DECF   x08,F
02C2:  BRA    02A4
....................     } 
....................  Output_Low(SCK);    
02C4:  BCF    F95.6
02C6:  BCF    F8C.6
....................  return(RdPara); 
02C8:  MOVFF  107,01
02CC:  MOVLB  0
02CE:  GOTO   02E4 (RETURN)
.................... } 
....................  
.................... int16 readRSSI(short forceTrigger) 
*
0706:  CLRF   xFA
0708:  CLRF   xF9
.................... { 
....................   int16 rssi = 0; 
....................   if (forceTrigger) 
070A:  MOVF   xF8,F
070C:  BZ    072C
....................   { 
....................     // RSSI trigger not needed if DAGC is in continuous mode 
....................     writeReg(REG_RSSICONFIG, RF_RSSI_START); 
070E:  MOVLW  23
0710:  MOVLB  1
0712:  MOVWF  x07
0714:  MOVLW  01
0716:  MOVWF  x08
0718:  MOVLB  0
071A:  RCALL  027E
....................     while ((readReg(REG_RSSICONFIG) & RF_RSSI_DONE) == 0x00); // wait for RSSI_Ready 
071C:  MOVLW  23
071E:  MOVLB  1
0720:  MOVWF  x05
0722:  MOVLB  0
0724:  RCALL  02D2
0726:  MOVF   01,W
0728:  ANDLW  02
072A:  BZ    071C
....................   } 
....................   rssi = -readReg(REG_RSSIVALUE); 
072C:  MOVLW  24
072E:  MOVLB  1
0730:  MOVWF  x05
0732:  MOVLB  0
0734:  RCALL  02D2
0736:  COMF   01,W
0738:  MOVWF  xF9
073A:  INCF   xF9,F
073C:  BTFSC  FD8.2
073E:  INCF   xFA,F
....................   rssi >>= 1; 
0740:  BCF    FD8.0
0742:  RRCF   xFA,F
0744:  RRCF   xF9,F
....................   return rssi; 
0746:  MOVFF  F9,01
074A:  MOVFF  FA,02
074E:  GOTO   0762 (RETURN)
.................... } 
....................  
.................... // internal function 
.................... void setHighPowerRegs(short onOff) { 
....................   writeReg(REG_TESTPA1, onOff ? 0x5D : 0x55); 
*
0352:  MOVLB  1
0354:  MOVF   x05,F
0356:  BZ    035C
0358:  MOVLW  5D
035A:  BRA    035E
035C:  MOVLW  55
035E:  MOVWF  x06
0360:  MOVLW  5A
0362:  MOVWF  x07
0364:  MOVFF  106,108
0368:  MOVLB  0
036A:  RCALL  027E
....................   writeReg(REG_TESTPA2, onOff ? 0x7C : 0x70); 
036C:  MOVLB  1
036E:  MOVF   x05,F
0370:  BZ    0376
0372:  MOVLW  7C
0374:  BRA    0378
0376:  MOVLW  70
0378:  MOVWF  x06
037A:  MOVLW  5C
037C:  MOVWF  x07
037E:  MOVFF  106,108
0382:  MOVLB  0
0384:  RCALL  027E
0386:  RETURN 0
.................... } 
....................  
....................  
.................... // ---------------------------------------- 
.................... //Variables--------------- 
.................... //GPS-- 
.................... char GPSData[128]; 
.................... unsigned int8 GPSDataPtr=0;  
.................... char c;  
.................... int8 GPSDataReady = FALSE;  
.................... int8 GPSmsgCount = 0;  
.................... //RMF69-- 
.................... byte TX_DATA[61]; 
.................... //AUX--- 
.................... //static unsigned int32 Cont = 0; 
.................... //short GPS_Status = 1; 
.................... //int tmr0 = 0; 
....................  
.................... //-------------------------------------- 
.................... //Funciones 
....................  
....................  
....................  
.................... void GPS_Pack() 
.................... { 
....................    for(int i=0; i<61; i++) 
*
0682:  CLRF   xEF
0684:  MOVF   xEF,W
0686:  SUBLW  3C
0688:  BNC   06BE
....................    { 
....................       GPSData[i]=GPSData[i+7]; 
068A:  CLRF   03
068C:  MOVF   xEF,W
068E:  ADDLW  2C
0690:  MOVWF  01
0692:  MOVLW  00
0694:  ADDWFC 03,F
0696:  MOVFF  03,F1
069A:  MOVLW  07
069C:  ADDWF  xEF,W
069E:  CLRF   03
06A0:  ADDLW  2C
06A2:  MOVWF  FE9
06A4:  MOVLW  00
06A6:  ADDWFC 03,W
06A8:  MOVWF  FEA
06AA:  MOVFF  FEF,F2
06AE:  MOVFF  F1,FEA
06B2:  MOVFF  01,FE9
06B6:  MOVFF  F2,FEF
06BA:  INCF   xEF,F
06BC:  BRA    0684
....................    } 
06BE:  GOTO   09F8 (RETURN)
.................... } 
....................  
.................... //------------------------ 
.................... //INT Lectura del UART GPS 
.................... #INT_RDA 
.................... void RDA_isr(void)  
.................... {  
....................    c = getc();  
*
0174:  BRA    0110
0176:  MOVFF  01,AD
....................    switch (c)  
017A:  MOVF   xAD,W
017C:  XORLW  24
017E:  BZ    0186
0180:  XORLW  2E
0182:  BZ    018A
0184:  BRA    01CE
....................    {  
....................       case '$':  
....................          GPSDataPtr = 0;  
0186:  CLRF   xAC
....................       break;  
0188:  BRA    01CE
....................        
....................       case '\n':  
....................          GPSmsgCount++; 
018A:  INCF   xAF,F
....................            if ( (StrFnd(GPSData, 'A', 0) == 17) && (GPSData[0]=='$') && (GPSData[1]== 'G') && (GPSData[2]== 'P') 
....................          && (GPSData[3]== 'R')&& (GPSData[4]== 'M') && (GPSData[5]== 'C')) 
018C:  MOVLB  1
018E:  CLRF   x0E
0190:  MOVLW  2C
0192:  MOVWF  x0D
0194:  MOVLW  41
0196:  MOVWF  x0F
0198:  CLRF   x11
019A:  CLRF   x10
019C:  MOVLB  0
019E:  BRA    0128
01A0:  MOVF   01,W
01A2:  SUBLW  11
01A4:  BNZ   01CE
01A6:  MOVF   2C,W
01A8:  SUBLW  24
01AA:  BNZ   01CE
01AC:  MOVF   2D,W
01AE:  SUBLW  47
01B0:  BNZ   01CE
01B2:  MOVF   2E,W
01B4:  SUBLW  50
01B6:  BNZ   01CE
01B8:  MOVF   2F,W
01BA:  SUBLW  52
01BC:  BNZ   01CE
01BE:  MOVF   30,W
01C0:  SUBLW  4D
01C2:  BNZ   01CE
01C4:  MOVF   31,W
01C6:  SUBLW  43
01C8:  BNZ   01CE
....................          { 
....................             GPSDataReady = TRUE; 
01CA:  MOVLW  01
01CC:  MOVWF  xAE
....................          } 
....................       break;  
....................    }  
....................      
....................    GPSData[GPSDataPtr++ & 0x7F] = c;  
01CE:  MOVF   xAC,W
01D0:  INCF   xAC,F
01D2:  ANDLW  7F
01D4:  CLRF   03
01D6:  ADDLW  2C
01D8:  MOVWF  FE9
01DA:  MOVLW  00
01DC:  ADDWFC 03,W
01DE:  MOVWF  FEA
01E0:  MOVFF  AD,FEF
01E4:  BCF    F9E.5
01E6:  GOTO   006C
.................... }  
.................... //--------------------------------------- 
.................... //INT timer0 
.................... /*#INT_TIMER0 
.................... void T0inter(void) 
.................... { 
....................  
....................    if((cont == 1400)        //1seg ~> cont = 12; 1min ~> cont = 700  
....................       && (GPS_Status == 0)) 
....................    { 
....................       Output_high(GPSPower); 
....................       cont = 0; 
....................       GPS_Status = 1; 
....................       break; 
....................    } 
....................    else 
....................       cont++; 
.................... }*/ 
....................  
.................... void main(void) 
*
0944:  CLRF   FF8
0946:  BCF    FD0.7
0948:  BSF    07.7
094A:  MOVLW  FE
094C:  MOVWF  00
094E:  MOVLW  08
0950:  MOVWF  01
0952:  MOVLW  02
0954:  MOVWF  FE9
0956:  MOVLW  00
0958:  MOVWF  FEA
095A:  CLRF   FEE
095C:  DECFSZ 00,F
095E:  BRA    095A
0960:  DECFSZ 01,F
0962:  BRA    095A
0964:  CLRF   1F
0966:  BSF    FB8.3
0968:  MOVLW  08
096A:  MOVWF  FAF
096C:  MOVLW  02
096E:  MOVWF  FB0
0970:  MOVLW  A6
0972:  MOVWF  FAC
0974:  MOVLW  90
0976:  MOVWF  FAB
0978:  CLRF   23
097A:  CLRF   22
097C:  CLRF   21
097E:  CLRF   20
0980:  MOVLW  B5
0982:  MOVWF  FCD
0984:  CLRF   FCF
0986:  CLRF   FCE
0988:  BCF    F9E.0
098A:  BSF    F9D.0
098C:  MOVLW  A6
098E:  MOVWF  24
0990:  BSF    2A.0
0992:  MOVLW  1F
0994:  MOVWF  2B
0996:  CLRF   xAC
0998:  CLRF   xAE
099A:  CLRF   xAF
099C:  CLRF   xEE
099E:  CLRF   xED
09A0:  MOVF   FC1,W
09A2:  ANDLW  C0
09A4:  IORLW  0F
09A6:  MOVWF  FC1
09A8:  MOVLW  07
09AA:  MOVWF  FB4
09AC:  CLRF   19
09AE:  CLRF   1A
09B0:  CLRF   25
09B2:  CLRF   26
09B4:  CLRF   27
09B6:  CLRF   28
09B8:  CLRF   29
.................... {  
.................... #zero_ram 
....................  
.................... set_tris_b(0b00000001);     //DIO0 
09BA:  MOVLW  01
09BC:  MOVWF  F93
.................... set_tris_C(0b10000000);     // ser in 0 
09BE:  MOVLW  80
09C0:  MOVWF  F94
.................... set_tris_D(0b00010000); 
09C2:  MOVLW  10
09C4:  MOVWF  F95
....................  
.................... //-------------------------------------- 
.................... //Config RFM69-------------------------- 
....................    Output_High(_slaveSelectPin); 
09C6:  BCF    F95.7
09C8:  BSF    F8C.7
....................    Output_Low(SCK); 
09CA:  BCF    F95.6
09CC:  BCF    F8C.6
....................    initialize(2); 
09CE:  MOVLW  02
09D0:  MOVWF  xEF
09D2:  BRA    0492
....................    delay_ms(500); 
09D4:  MOVLW  02
09D6:  MOVWF  xEF
09D8:  MOVLW  FA
09DA:  MOVWF  xF0
09DC:  RCALL  065C
09DE:  DECFSZ xEF,F
09E0:  BRA    09D8
....................    setHighPower(1); 
09E2:  MOVLW  01
09E4:  MOVWF  xF7
09E6:  RCALL  02F4
....................    //readAllRegs(); 
.................... //-------------------------------------- 
.................... //Config GPS 
....................    //GPRMCInfo MyGPRMCInfo; 
.................... //-------------------------------------- 
....................    //setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit); //86ms ~ RTCC_DIV_256|RTCC_8_bit 
....................   // set_timer0(tmr0);                                     //86ms ~ tmr0=0; 
....................   
.................... //1seg ~> cont = 12; 1min ~> cont = 700  
.................... //------------------------------------------------------------  
....................    Output_high(GPSPower); 
09E8:  BCF    F95.2
09EA:  BSF    F8C.2
....................    enable_interrupts(GLOBAL); 
09EC:  MOVLW  C0
09EE:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
09F0:  BSF    F9D.5
.................... //   enable_interrupts(INT_TIMER0); 
....................  
....................     
....................  
.................... // -------------------------------------------------------------- 
.................... while(true) 
....................    { 
....................       if (GPSDataReady) 
09F2:  MOVF   xAE,F
09F4:  BZ    0A40
....................       {  
....................          //GPRMC_decode(GPSData, &MyGPRMCInfo); 
....................          //if (MyGPRMCInfo.Valid == 'A')  
....................          //{  
....................             GPS_Pack(); 
09F6:  BRA    0682
....................             sprintf(TX_DATA, "%s", GPSData); 
09F8:  CLRF   xEE
09FA:  MOVLW  B0
09FC:  MOVWF  xED
09FE:  MOVFF  EE,FEA
0A02:  MOVFF  ED,FE9
0A06:  CLRF   FEF
0A08:  CLRF   FEA
0A0A:  MOVLW  2C
0A0C:  MOVWF  FE9
0A0E:  BRA    06E0
....................            // for (int i = 0; i < 2; i ++) 
....................             //{ 
....................                send(0x01, TX_DATA, 61, 0); 
0A10:  MOVLW  01
0A12:  MOVWF  xEF
0A14:  CLRF   xF1
0A16:  MOVLW  B0
0A18:  MOVWF  xF0
0A1A:  MOVLW  3D
0A1C:  MOVWF  xF2
0A1E:  CLRF   xF3
0A20:  BRA    08B6
....................                delay_ms(100); 
0A22:  MOVLW  64
0A24:  MOVWF  xF0
0A26:  RCALL  065C
....................             //} 
....................              
....................          //} 
....................          Output_low(GPSPower); 
0A28:  BCF    F95.2
0A2A:  BCF    F8C.2
....................          delay_ms(20000); 
0A2C:  MOVLW  50
0A2E:  MOVWF  xEF
0A30:  MOVLW  FA
0A32:  MOVWF  xF0
0A34:  RCALL  065C
0A36:  DECFSZ xEF,F
0A38:  BRA    0A30
....................          Output_high(GPSPower); 
0A3A:  BCF    F95.2
0A3C:  BSF    F8C.2
....................          GPSDataReady = FALSE;  
0A3E:  CLRF   xAE
....................       }   
0A40:  BRA    09F2
....................           
....................  
....................    } 
....................    // End While Loop 
.................... }         // End Main  
....................  
0A42:  SLEEP 
....................  
.................... /*****************************************************************************/ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV21 NOVREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
