CCS PCH C Compiler, Version 5.059, 5967               05-jun.-17 16:23

               Filename:   C:\Users\Jesus\Documents\GitHub\TESIS\Funciona\Transmisor + gps\rmf69.lst

               ROM used:   2872 bytes (9%)
                           Largest free fragment is 29896
               RAM used:   245 (12%) at main() level
                           284 (14%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   09DC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   0116
0060:  BTFSS  F9D.1
0062:  GOTO   006C
0066:  BTFSC  F9E.1
0068:  GOTO   012C
006C:  BTFSS  FF0.4
006E:  GOTO   0078
0072:  BTFSC  FF0.1
0074:  GOTO   0224
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   01AE
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
*
0126:  BCF    F9E.0
0128:  GOTO   0084
.................... #device PIC18F4550 
*
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 01,04
00E4:  DATA 02,00
00E6:  DATA 03,68
00E8:  DATA 04,2B
00EA:  DATA 05,03
00EC:  DATA 06,33
00EE:  DATA 07,E4
00F0:  DATA 08,C0
00F2:  DATA 09,00
00F4:  DATA 11,FF
00F6:  DATA 13,1A
00F8:  DATA 19,42
00FA:  DATA 25,40
00FC:  DATA 26,07
00FE:  DATA 28,10
0100:  DATA 29,DC
0102:  DATA 2D,03
0104:  DATA 2E,88
0106:  DATA 2F,2D
0108:  DATA 30,01
010A:  DATA 37,90
010C:  DATA 38,42
010E:  DATA 3C,8F
0110:  DATA 3D,12
0112:  DATA 6F,30
0114:  DATA FF,00
0116:  MOVLW  01
0118:  ADDWF  20,F
011A:  BTFSC  FD8.0
011C:  INCF   21,F
011E:  BTFSC  FD8.2
0120:  INCF   22,F
0122:  BTFSC  FD8.2
0124:  INCF   23,F
*
0236:  DATA 45,52
0238:  DATA 52,4F
023A:  DATA 52,2C
023C:  DATA 64,65
023E:  DATA 73,63
0240:  DATA 6F,6E
0242:  DATA 65,63
0244:  DATA 74,61
0246:  DATA 64,6F
0248:  DATA 00,00
*
0722:  MOVFF  F2,FEA
0726:  MOVFF  F1,FE9
072A:  MOVFF  F6,FEF
072E:  INCF   FE9,F
0730:  BTFSC  FD8.2
0732:  INCF   FEA,F
0734:  CLRF   FEF
0736:  INCF   xF1,F
0738:  BTFSC  FD8.2
073A:  INCF   xF2,F
073C:  RETURN 0
073E:  MOVF   FEF,F
0740:  BZ    0760
0742:  MOVFF  FEA,F5
0746:  MOVFF  FE9,F4
074A:  MOVFF  FEF,F6
074E:  RCALL  0722
0750:  MOVFF  F5,FEA
0754:  MOVFF  F4,FE9
0758:  INCF   FE9,F
075A:  BTFSC  FD8.2
075C:  INCF   FEA,F
075E:  BRA    073E
0760:  GOTO   0AE4 (RETURN)
*
09BA:  TBLRD*+
09BC:  MOVF   FF5,F
09BE:  BZ    09D8
09C0:  MOVFF  FF6,F4
09C4:  MOVFF  FF7,F5
09C8:  MOVFF  FF5,F6
09CC:  RCALL  0722
09CE:  MOVFF  F4,FF6
09D2:  MOVFF  F5,FF7
09D6:  BRA    09BA
09D8:  GOTO   0B14 (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #Fuses HS, nowdt, nolvp, novregen, noprotect, nomclr, noPUT, nobrownout 
.................... #use delay(clock=20M, crystal=20M) // a 3.3V se transforma en ~3MHZ 
*
06BC:  CLRF   FEA
06BE:  MOVLW  F5
06C0:  MOVWF  FE9
06C2:  MOVF   FEF,W
06C4:  BZ    06E0
06C6:  MOVLW  06
06C8:  MOVWF  01
06CA:  CLRF   00
06CC:  DECFSZ 00,F
06CE:  BRA    06CC
06D0:  DECFSZ 01,F
06D2:  BRA    06CA
06D4:  MOVLW  7B
06D6:  MOVWF  00
06D8:  DECFSZ 00,F
06DA:  BRA    06D8
06DC:  DECFSZ FEF,F
06DE:  BRA    06C6
06E0:  RETURN 0
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=GPS,errors) 
*
014A:  BTFSS  F9E.5
014C:  BRA    014A
014E:  MOVFF  FAB,1F
0152:  MOVFF  FAE,01
0156:  BTFSS  1F.1
0158:  BRA    015E
015A:  BCF    FAB.4
015C:  BSF    FAB.4
015E:  GOTO   01B0 (RETURN)
.................... #USE TIMER(TIMER=1,TICK=1ms,BITS=32,ISR) 
*
024A:  MOVFF  20,01
024E:  MOVF   FCE,W
0250:  MOVFF  FCF,03
0254:  BCF    F9D.0
0256:  MOVWF  02
0258:  MOVF   20,W
025A:  SUBWF  01,W
025C:  BZ    0266
025E:  MOVF   FCE,W
0260:  MOVFF  FCF,03
0264:  BRA    0268
0266:  MOVF   02,W
0268:  MOVFF  03,00
026C:  MOVFF  20,01
0270:  MOVFF  21,02
0274:  MOVFF  22,03
0278:  MOVF   23,W
027A:  RRCF   FE8,F
027C:  RRCF   03,F
027E:  RRCF   02,F
0280:  RRCF   01,F
0282:  RRCF   00,F
0284:  BSF    F9D.0
0286:  GOTO   0006 (RETURN)
....................  
.................... //----------------------------------------- 
.................... //Definicion pines RFM69 
.................... #define _slaveSelectPin Pin_D7 
.................... #define SCK             Pin_D6 
.................... #define SerOut          Pin_D5 
.................... #define SerIn           Pin_D4 
.................... #define _interruptPin   Pin_B0 
.................... #define GPSPower        Pin_D2 
....................  
....................   
....................  
.................... //----------------------------------------- 
.................... #include "GPS.c"  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... #include <string.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... typedef struct _DateTimeInfo  
.................... {  
....................    int8 Day;  
....................    int8 Month;  
....................    int8 Year;  
....................    int8 Hour;  
....................    int8 Minute;  
....................    int8 Second;  
.................... } DateTimeInfo;  
.................... ////////////////////////////////////////  
.................... typedef struct _GPRMCInfo  
.................... {  
....................    char Valid;  
....................    DateTimeInfo DT;  
....................    float Latitude;  
....................    char N_S;  
....................    float Longitude;  
....................    char E_W;  
....................    float Speed;  
.................... } GPRMCInfo;  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... //copy string (pos n to pos m) from s2 to s1  
.................... char* StrnmCpy(char *s1, char *s2, size_t n, size_t m)  
.................... {  
....................    int8 i;  
....................    char *s;  
....................      
....................    for (s=s1, i=n, s2+=n; i<=m; i++)  
....................       *s++ = *s2++;  
....................    *s = '\0';  
....................      
....................    return s1;  
.................... }  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... // find c in s starting from pos st  
.................... int8 StrFnd(char *s, char c, size_t st)  
.................... {  
....................    int8 l;  
....................      
....................    for (l=st, s+=st ; *s != '\0' ; l++, s++)  
*
0162:  MOVFF  118,11A
0166:  MOVLB  1
0168:  MOVF   x18,W
016A:  ADDWF  x15,F
016C:  MOVF   x19,W
016E:  ADDWFC x16,F
0170:  MOVFF  116,03
0174:  MOVFF  115,FE9
0178:  MOVFF  116,FEA
017C:  MOVF   FEF,F
017E:  BZ    01A4
....................       if (*s == c)  
0180:  MOVFF  116,03
0184:  MOVFF  115,FE9
0188:  MOVFF  116,FEA
018C:  MOVF   x17,W
018E:  SUBWF  FEF,W
0190:  BNZ   0198
....................          return l;  
0192:  MOVFF  11A,01
0196:  BRA    01A8
0198:  MOVF   x1A,W
019A:  INCF   x1A,F
019C:  INCF   x15,F
019E:  BTFSC  FD8.2
01A0:  INCF   x16,F
01A2:  BRA    0170
....................    return -1;  
01A4:  MOVLW  FF
01A6:  MOVWF  01
01A8:  MOVLB  0
01AA:  GOTO   01DA (RETURN)
.................... }  
.................... ///////////////////////////////////////////////////////////////////////////////  
.................... void GPRMC_decode(char *GPRMCStr, GPRMCInfo *RMCInfo)  
.................... {  
....................    int8 p1, p2;  
....................    char TempStr[16];  
....................      
....................    p1 = StrFnd(GPRMCStr, ',', 0);      //find first comma  
....................    if (p1 == 6)  
....................    {  
....................       //check for valid packet:  
....................       if ( (StrFnd(GPRMCStr, 'A', 0) == 17) && (GPRMCStr[0]=='$')) //valid?  
....................       { 
....................          RMCInfo->Valid = 'A';  
....................            
....................          //Get time  
....................          p1 = StrFnd(GPRMCStr, ',', 0);      //find first comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->DT.Hour = atoi(StrnmCpy(TempStr, GPRMCStr, p1+1, p1+2));   //hour  
....................          RMCInfo->DT.Minute = atoi(StrnmCpy(TempStr, GPRMCStr, p1+3, p1+4)); //min  
....................          RMCInfo->DT.Second = atoi(StrnmCpy(TempStr, GPRMCStr, p1+5, p1+6)); //sec  
....................            
....................          //Get latitude & direction  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->Latitude = atof(StrnmCpy(TempStr, GPRMCStr, p1+1, p2-1));  
....................          RMCInfo->N_S = GPRMCStr[p2+1];  
....................            
....................          //Get longitude & direction  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->Longitude = atof(StrnmCpy(TempStr, GPRMCStr, p1+1, p2-1));  
....................          RMCInfo->E_W = GPRMCStr[p2+1];  
....................            
....................          //Get speed  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->Speed = atof(StrnmCpy(TempStr, GPRMCStr, p1+1, p2-1));  
....................            
....................          //Get date  
....................          p1 = StrFnd(GPRMCStr, ',', p2+1);   //find next comma  
....................          p2 = StrFnd(GPRMCStr, ',', p1+1);   //find next comma  
....................          RMCInfo->DT.Day = atoi(StrnmCpy(TempStr, GPRMCStr, p1+1, p1+2));  //dd  
....................          RMCInfo->DT.Month = atoi(StrnmCpy(TempStr, GPRMCStr, p1+3, p1+4));//mm  
....................          RMCInfo->DT.year = atoi(StrnmCpy(TempStr, GPRMCStr, p1+5, p1+6)); //yy  
....................       }  
....................       else                                //not valid  
....................       {  
....................          RMCInfo->Valid = 'V';  
....................       }  
....................    }  
.................... }  
....................  
.................... // ---------------------------------------- 
.................... #include "RFM69.h" 
.................... #include <RFM69registers.h> 
.................... // ********************************************************************************** 
.................... // Registers used in driver definition for HopeRF RFM69W/RFM69HW, Semtech SX1231/1231H 
.................... // ********************************************************************************** 
.................... // Copyright Felix Rusu (2015), felix@lowpowerlab.com 
.................... // http://lowpowerlab.com/ 
.................... // ********************************************************************************** 
.................... // License 
.................... // ********************************************************************************** 
.................... // This program is free software; you can redistribute it  
.................... // and/or modify it under the terms of the GNU General     
.................... // Public License as published by the Free Software        
.................... // Foundation; either version 2 of the License, or         
.................... // (at your option) any later version.                     
.................... //                                                         
.................... // This program is distributed in the hope that it will    
.................... // be useful, but WITHOUT ANY WARRANTY; without even the   
.................... // implied warranty of MERCHANTABILITY or FITNESS FOR A    
.................... // PARTICULAR PURPOSE.  See the GNU General Public         
.................... // License for more details.                               
.................... //                                                         
.................... // You should have received a copy of the GNU General     
.................... // Public License along with this program; if not, write  
.................... // to the Free Software Foundation, Inc.,                 
.................... // 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA 
.................... //                                                         
.................... // Licence can be viewed at                                
.................... // http://www.fsf.org/licenses/gpl.txt                     
.................... // 
.................... // Please maintain this license information along with authorship 
.................... // and copyright notices in any redistribution of this code 
.................... // ********************************************************************************** 
.................... // RFM69/SX1231 Internal registers addresses 
.................... //************************************************** 
.................... #define REG_FIFO          0x00 
.................... #define REG_OPMODE        0x01 
.................... #define REG_DATAMODUL     0x02 
.................... #define REG_BITRATEMSB    0x03 
.................... #define REG_BITRATELSB    0x04 
.................... #define REG_FDEVMSB       0x05 
.................... #define REG_FDEVLSB       0x06 
.................... #define REG_FRFMSB        0x07 
.................... #define REG_FRFMID        0x08 
.................... #define REG_FRFLSB        0x09 
.................... #define REG_OSC1          0x0A 
.................... #define REG_AFCCTRL       0x0B 
.................... #define REG_LOWBAT        0x0C 
.................... #define REG_LISTEN1       0x0D 
.................... #define REG_LISTEN2       0x0E 
.................... #define REG_LISTEN3       0x0F 
.................... #define REG_VERSION       0x10 
.................... #define REG_PALEVEL       0x11 
.................... #define REG_PARAMP        0x12 
.................... #define REG_OCP           0x13 
.................... #define REG_AGCREF        0x14  // not present on RFM69/SX1231 
.................... #define REG_AGCTHRESH1    0x15  // not present on RFM69/SX1231 
.................... #define REG_AGCTHRESH2    0x16  // not present on RFM69/SX1231 
.................... #define REG_AGCTHRESH3    0x17  // not present on RFM69/SX1231 
.................... #define REG_LNA           0x18 
.................... #define REG_RXBW          0x19 
.................... #define REG_AFCBW         0x1A 
.................... #define REG_OOKPEAK       0x1B 
.................... #define REG_OOKAVG        0x1C 
.................... #define REG_OOKFIX        0x1D 
.................... #define REG_AFCFEI        0x1E 
.................... #define REG_AFCMSB        0x1F 
.................... #define REG_AFCLSB        0x20 
.................... #define REG_FEIMSB        0x21 
.................... #define REG_FEILSB        0x22 
.................... #define REG_RSSICONFIG    0x23 
.................... #define REG_RSSIVALUE     0x24 
.................... #define REG_DIOMAPPING1   0x25 
.................... #define REG_DIOMAPPING2   0x26 
.................... #define REG_IRQFLAGS1     0x27 
.................... #define REG_IRQFLAGS2     0x28 
.................... #define REG_RSSITHRESH    0x29 
.................... #define REG_RXTIMEOUT1    0x2A 
.................... #define REG_RXTIMEOUT2    0x2B 
.................... #define REG_PREAMBLEMSB   0x2C 
.................... #define REG_PREAMBLELSB   0x2D 
.................... #define REG_SYNCCONFIG    0x2E 
.................... #define REG_SYNCVALUE1    0x2F 
.................... #define REG_SYNCVALUE2    0x30 
.................... #define REG_SYNCVALUE3    0x31 
.................... #define REG_SYNCVALUE4    0x32 
.................... #define REG_SYNCVALUE5    0x33 
.................... #define REG_SYNCVALUE6    0x34 
.................... #define REG_SYNCVALUE7    0x35 
.................... #define REG_SYNCVALUE8    0x36 
.................... #define REG_PACKETCONFIG1 0x37 
.................... #define REG_PAYLOADLENGTH 0x38 
.................... #define REG_NODEADRS      0x39 
.................... #define REG_BROADCASTADRS 0x3A 
.................... #define REG_AUTOMODES     0x3B 
.................... #define REG_FIFOTHRESH    0x3C 
.................... #define REG_PACKETCONFIG2 0x3D 
.................... #define REG_AESKEY1       0x3E 
.................... #define REG_AESKEY2       0x3F 
.................... #define REG_AESKEY3       0x40 
.................... #define REG_AESKEY4       0x41 
.................... #define REG_AESKEY5       0x42 
.................... #define REG_AESKEY6       0x43 
.................... #define REG_AESKEY7       0x44 
.................... #define REG_AESKEY8       0x45 
.................... #define REG_AESKEY9       0x46 
.................... #define REG_AESKEY10      0x47 
.................... #define REG_AESKEY11      0x48 
.................... #define REG_AESKEY12      0x49 
.................... #define REG_AESKEY13      0x4A 
.................... #define REG_AESKEY14      0x4B 
.................... #define REG_AESKEY15      0x4C 
.................... #define REG_AESKEY16      0x4D 
.................... #define REG_TEMP1         0x4E 
.................... #define REG_TEMP2         0x4F 
.................... #define REG_TESTLNA       0x58 
.................... #define REG_TESTPA1       0x5A  // only present on RFM69HW/SX1231H 
.................... #define REG_TESTPA2       0x5C  // only present on RFM69HW/SX1231H 
.................... #define REG_TESTDAGC      0x6F 
....................  
.................... //****************************************************** 
.................... // RF69/SX1231 bit control definition 
.................... //****************************************************** 
....................  
.................... // RegOpMode 
.................... #define RF_OPMODE_SEQUENCER_OFF       0x80 
.................... #define RF_OPMODE_SEQUENCER_ON        0x00  // Default 
....................  
.................... #define RF_OPMODE_LISTEN_ON           0x40 
.................... #define RF_OPMODE_LISTEN_OFF          0x00  // Default 
....................  
.................... #define RF_OPMODE_LISTENABORT         0x20 
....................  
.................... #define RF_OPMODE_SLEEP               0x00 
.................... #define RF_OPMODE_STANDBY             0x04  // Default 
.................... #define RF_OPMODE_SYNTHESIZER         0x08 
.................... #define RF_OPMODE_TRANSMITTER         0x0C 
.................... #define RF_OPMODE_RECEIVER            0x10 
....................  
....................  
.................... // RegDataModul 
.................... #define RF_DATAMODUL_DATAMODE_PACKET            0x00  // Default 
.................... #define RF_DATAMODUL_DATAMODE_CONTINUOUS        0x40 
.................... #define RF_DATAMODUL_DATAMODE_CONTINUOUSNOBSYNC 0x60 
....................  
.................... #define RF_DATAMODUL_MODULATIONTYPE_FSK         0x00  // Default 
.................... #define RF_DATAMODUL_MODULATIONTYPE_OOK         0x08 
....................  
.................... #define RF_DATAMODUL_MODULATIONSHAPING_00       0x00  // Default 
.................... #define RF_DATAMODUL_MODULATIONSHAPING_01       0x01 
.................... #define RF_DATAMODUL_MODULATIONSHAPING_10       0x02 
.................... #define RF_DATAMODUL_MODULATIONSHAPING_11       0x03 
....................  
....................  
.................... // RegBitRate (bits/sec) example bit rates 
.................... #define RF_BITRATEMSB_1200            0x68 
.................... #define RF_BITRATELSB_1200            0x2B 
.................... #define RF_BITRATEMSB_2400            0x34 
.................... #define RF_BITRATELSB_2400            0x15 
.................... #define RF_BITRATEMSB_4800            0x1A  // Default 
.................... #define RF_BITRATELSB_4800            0x0B  // Default 
.................... #define RF_BITRATEMSB_9600            0x0D 
.................... #define RF_BITRATELSB_9600            0x05 
.................... #define RF_BITRATEMSB_19200           0x06 
.................... #define RF_BITRATELSB_19200           0x83 
.................... #define RF_BITRATEMSB_38400           0x03 
.................... #define RF_BITRATELSB_38400           0x41 
....................  
.................... #define RF_BITRATEMSB_38323           0x03 
.................... #define RF_BITRATELSB_38323           0x43 
....................  
.................... #define RF_BITRATEMSB_34482           0x03 
.................... #define RF_BITRATELSB_34482           0xA0 
....................  
.................... #define RF_BITRATEMSB_76800           0x01 
.................... #define RF_BITRATELSB_76800           0xA1 
.................... #define RF_BITRATEMSB_153600          0x00 
.................... #define RF_BITRATELSB_153600          0xD0 
.................... #define RF_BITRATEMSB_57600           0x02 
.................... #define RF_BITRATELSB_57600           0x2C 
.................... #define RF_BITRATEMSB_115200          0x01 
.................... #define RF_BITRATELSB_115200          0x16 
.................... #define RF_BITRATEMSB_12500           0x0A 
.................... #define RF_BITRATELSB_12500           0x00 
.................... #define RF_BITRATEMSB_25000           0x05 
.................... #define RF_BITRATELSB_25000           0x00 
.................... #define RF_BITRATEMSB_50000           0x02 
.................... #define RF_BITRATELSB_50000           0x80 
.................... #define RF_BITRATEMSB_100000          0x01 
.................... #define RF_BITRATELSB_100000          0x40 
.................... #define RF_BITRATEMSB_150000          0x00 
.................... #define RF_BITRATELSB_150000          0xD5 
.................... #define RF_BITRATEMSB_200000          0x00 
.................... #define RF_BITRATELSB_200000          0xA0 
.................... #define RF_BITRATEMSB_250000          0x00 
.................... #define RF_BITRATELSB_250000          0x80 
.................... #define RF_BITRATEMSB_300000          0x00 
.................... #define RF_BITRATELSB_300000          0x6B 
.................... #define RF_BITRATEMSB_32768           0x03 
.................... #define RF_BITRATELSB_32768           0xD1 
.................... // custom bit rates 
.................... #define RF_BITRATEMSB_55555           0x02 
.................... #define RF_BITRATELSB_55555           0x40 
.................... #define RF_BITRATEMSB_200KBPS         0x00 
.................... #define RF_BITRATELSB_200KBPS         0xa0 
....................  
....................  
.................... // RegFdev - frequency deviation (Hz) 
.................... #define RF_FDEVMSB_2000             0x00 
.................... #define RF_FDEVLSB_2000             0x21 
.................... #define RF_FDEVMSB_5000             0x00  // Default 
.................... #define RF_FDEVLSB_5000             0x52  // Default 
.................... #define RF_FDEVMSB_7500             0x00 
.................... #define RF_FDEVLSB_7500             0x7B 
.................... #define RF_FDEVMSB_10000            0x00 
.................... #define RF_FDEVLSB_10000            0xA4 
.................... #define RF_FDEVMSB_15000            0x00 
.................... #define RF_FDEVLSB_15000            0xF6 
.................... #define RF_FDEVMSB_20000            0x01 
.................... #define RF_FDEVLSB_20000            0x48 
.................... #define RF_FDEVMSB_25000            0x01 
.................... #define RF_FDEVLSB_25000            0x9A 
.................... #define RF_FDEVMSB_30000            0x01 
.................... #define RF_FDEVLSB_30000            0xEC 
.................... #define RF_FDEVMSB_35000            0x02 
.................... #define RF_FDEVLSB_35000            0x3D 
.................... #define RF_FDEVMSB_40000            0x02 
.................... #define RF_FDEVLSB_40000            0x8F 
.................... #define RF_FDEVMSB_45000            0x02 
.................... #define RF_FDEVLSB_45000            0xE1 
.................... #define RF_FDEVMSB_50000            0x03 
.................... #define RF_FDEVLSB_50000            0x33 
.................... #define RF_FDEVMSB_55000            0x03 
.................... #define RF_FDEVLSB_55000            0x85 
.................... #define RF_FDEVMSB_60000            0x03 
.................... #define RF_FDEVLSB_60000            0xD7 
.................... #define RF_FDEVMSB_65000            0x04 
.................... #define RF_FDEVLSB_65000            0x29 
.................... #define RF_FDEVMSB_70000            0x04 
.................... #define RF_FDEVLSB_70000            0x7B 
.................... #define RF_FDEVMSB_75000            0x04 
.................... #define RF_FDEVLSB_75000            0xCD 
.................... #define RF_FDEVMSB_80000            0x05 
.................... #define RF_FDEVLSB_80000            0x1F 
.................... #define RF_FDEVMSB_85000            0x05 
.................... #define RF_FDEVLSB_85000            0x71 
.................... #define RF_FDEVMSB_90000            0x05 
.................... #define RF_FDEVLSB_90000            0xC3 
.................... #define RF_FDEVMSB_95000            0x06 
.................... #define RF_FDEVLSB_95000            0x14 
.................... #define RF_FDEVMSB_100000           0x06 
.................... #define RF_FDEVLSB_100000           0x66 
.................... #define RF_FDEVMSB_110000           0x07 
.................... #define RF_FDEVLSB_110000           0x0A 
.................... #define RF_FDEVMSB_120000           0x07 
.................... #define RF_FDEVLSB_120000           0xAE 
.................... #define RF_FDEVMSB_130000           0x08 
.................... #define RF_FDEVLSB_130000           0x52 
.................... #define RF_FDEVMSB_140000           0x08 
.................... #define RF_FDEVLSB_140000           0xF6 
.................... #define RF_FDEVMSB_150000           0x09 
.................... #define RF_FDEVLSB_150000           0x9A 
.................... #define RF_FDEVMSB_160000           0x0A 
.................... #define RF_FDEVLSB_160000           0x3D 
.................... #define RF_FDEVMSB_170000           0x0A 
.................... #define RF_FDEVLSB_170000           0xE1 
.................... #define RF_FDEVMSB_180000           0x0B 
.................... #define RF_FDEVLSB_180000           0x85 
.................... #define RF_FDEVMSB_190000           0x0C 
.................... #define RF_FDEVLSB_190000           0x29 
.................... #define RF_FDEVMSB_200000           0x0C 
.................... #define RF_FDEVLSB_200000           0xCD 
.................... #define RF_FDEVMSB_210000           0x0D 
.................... #define RF_FDEVLSB_210000           0x71 
.................... #define RF_FDEVMSB_220000           0x0E 
.................... #define RF_FDEVLSB_220000           0x14 
.................... #define RF_FDEVMSB_230000           0x0E 
.................... #define RF_FDEVLSB_230000           0xB8 
.................... #define RF_FDEVMSB_240000           0x0F 
.................... #define RF_FDEVLSB_240000           0x5C 
.................... #define RF_FDEVMSB_250000           0x10 
.................... #define RF_FDEVLSB_250000           0x00 
.................... #define RF_FDEVMSB_260000           0x10 
.................... #define RF_FDEVLSB_260000           0xA4 
.................... #define RF_FDEVMSB_270000           0x11 
.................... #define RF_FDEVLSB_270000           0x48 
.................... #define RF_FDEVMSB_280000           0x11 
.................... #define RF_FDEVLSB_280000           0xEC 
.................... #define RF_FDEVMSB_290000           0x12 
.................... #define RF_FDEVLSB_290000           0x8F 
.................... #define RF_FDEVMSB_300000           0x13 
.................... #define RF_FDEVLSB_300000           0x33 
....................  
....................  
.................... // RegFrf (MHz) - carrier frequency 
.................... // 315Mhz band 
.................... #define RF_FRFMSB_314             0x4E 
.................... #define RF_FRFMID_314             0x80 
.................... #define RF_FRFLSB_314             0x00 
.................... #define RF_FRFMSB_315             0x4E 
.................... #define RF_FRFMID_315             0xC0 
.................... #define RF_FRFLSB_315             0x00 
.................... #define RF_FRFMSB_316             0x4F 
.................... #define RF_FRFMID_316             0x00 
.................... #define RF_FRFLSB_316             0x00 
.................... // 433mhz band 
.................... #define RF_FRFMSB_433             0x6C 
.................... #define RF_FRFMID_433             0x40 
.................... #define RF_FRFLSB_433             0x00 
.................... #define RF_FRFMSB_434             0x6C 
.................... #define RF_FRFMID_434             0x80 
.................... #define RF_FRFLSB_434             0x00 
.................... #define RF_FRFMSB_435             0x6C 
.................... #define RF_FRFMID_435             0xC0 
.................... #define RF_FRFLSB_435             0x00 
.................... // 868Mhz band 
.................... #define RF_FRFMSB_863             0xD7 
.................... #define RF_FRFMID_863             0xC0 
.................... #define RF_FRFLSB_863             0x00 
.................... #define RF_FRFMSB_864             0xD8 
.................... #define RF_FRFMID_864             0x00 
.................... #define RF_FRFLSB_864             0x00 
.................... #define RF_FRFMSB_865             0xD8 
.................... #define RF_FRFMID_865             0x40 
.................... #define RF_FRFLSB_865             0x00 
.................... #define RF_FRFMSB_866             0xD8 
.................... #define RF_FRFMID_866             0x80 
.................... #define RF_FRFLSB_866             0x00 
.................... #define RF_FRFMSB_867             0xD8 
.................... #define RF_FRFMID_867             0xC0 
.................... #define RF_FRFLSB_867             0x00 
.................... #define RF_FRFMSB_868             0xD9 
.................... #define RF_FRFMID_868             0x00 
.................... #define RF_FRFLSB_868             0x00 
.................... #define RF_FRFMSB_869             0xD9 
.................... #define RF_FRFMID_869             0x40 
.................... #define RF_FRFLSB_869             0x00 
.................... #define RF_FRFMSB_870             0xD9 
.................... #define RF_FRFMID_870             0x80 
.................... #define RF_FRFLSB_870             0x00 
.................... // 915Mhz band 
.................... #define RF_FRFMSB_902             0xE1 
.................... #define RF_FRFMID_902             0x80 
.................... #define RF_FRFLSB_902             0x00 
.................... #define RF_FRFMSB_903             0xE1 
.................... #define RF_FRFMID_903             0xC0 
.................... #define RF_FRFLSB_903             0x00 
.................... #define RF_FRFMSB_904             0xE2 
.................... #define RF_FRFMID_904             0x00 
.................... #define RF_FRFLSB_904             0x00 
.................... #define RF_FRFMSB_905             0xE2 
.................... #define RF_FRFMID_905             0x40 
.................... #define RF_FRFLSB_905             0x00 
.................... #define RF_FRFMSB_906             0xE2 
.................... #define RF_FRFMID_906             0x80 
.................... #define RF_FRFLSB_906             0x00 
.................... #define RF_FRFMSB_907             0xE2 
.................... #define RF_FRFMID_907             0xC0 
.................... #define RF_FRFLSB_907             0x00 
.................... #define RF_FRFMSB_908             0xE3 
.................... #define RF_FRFMID_908             0x00 
.................... #define RF_FRFLSB_908             0x00 
.................... #define RF_FRFMSB_909             0xE3 
.................... #define RF_FRFMID_909             0x40 
.................... #define RF_FRFLSB_909             0x00 
.................... #define RF_FRFMSB_910             0xE3 
.................... #define RF_FRFMID_910             0x80 
.................... #define RF_FRFLSB_910             0x00 
.................... #define RF_FRFMSB_911             0xE3 
.................... #define RF_FRFMID_911             0xC0 
.................... #define RF_FRFLSB_911             0x00 
.................... #define RF_FRFMSB_912             0xE4 
.................... #define RF_FRFMID_912             0x00 
.................... #define RF_FRFLSB_912             0x00 
.................... #define RF_FRFMSB_913             0xE4 
.................... #define RF_FRFMID_913             0x40 
.................... #define RF_FRFLSB_913             0x00 
.................... #define RF_FRFMSB_914             0xE4 
.................... #define RF_FRFMID_914             0x80 
.................... #define RF_FRFLSB_914             0x00 
.................... #define RF_FRFMSB_915             0xE4  // Default 
.................... #define RF_FRFMID_915             0xC0  // Default 
.................... #define RF_FRFLSB_915             0x00  // Default 
.................... #define RF_FRFMSB_916             0xE5 
.................... #define RF_FRFMID_916             0x00 
.................... #define RF_FRFLSB_916             0x00 
.................... #define RF_FRFMSB_917             0xE5 
.................... #define RF_FRFMID_917             0x40 
.................... #define RF_FRFLSB_917             0x00 
.................... #define RF_FRFMSB_918             0xE5 
.................... #define RF_FRFMID_918             0x80 
.................... #define RF_FRFLSB_918             0x00 
.................... #define RF_FRFMSB_919             0xE5 
.................... #define RF_FRFMID_919             0xC0 
.................... #define RF_FRFLSB_919             0x00 
.................... #define RF_FRFMSB_920             0xE6 
.................... #define RF_FRFMID_920             0x00 
.................... #define RF_FRFLSB_920             0x00 
.................... #define RF_FRFMSB_921             0xE6 
.................... #define RF_FRFMID_921             0x40 
.................... #define RF_FRFLSB_921             0x00 
.................... #define RF_FRFMSB_922             0xE6 
.................... #define RF_FRFMID_922             0x80 
.................... #define RF_FRFLSB_922             0x00 
.................... #define RF_FRFMSB_923             0xE6 
.................... #define RF_FRFMID_923             0xC0 
.................... #define RF_FRFLSB_923             0x00 
.................... #define RF_FRFMSB_924             0xE7 
.................... #define RF_FRFMID_924             0x00 
.................... #define RF_FRFLSB_924             0x00 
.................... #define RF_FRFMSB_925             0xE7 
.................... #define RF_FRFMID_925             0x40 
.................... #define RF_FRFLSB_925             0x00 
.................... #define RF_FRFMSB_926             0xE7 
.................... #define RF_FRFMID_926             0x80 
.................... #define RF_FRFLSB_926             0x00 
.................... #define RF_FRFMSB_927             0xE7 
.................... #define RF_FRFMID_927             0xC0 
.................... #define RF_FRFLSB_927             0x00 
.................... #define RF_FRFMSB_928             0xE8 
.................... #define RF_FRFMID_928             0x00 
.................... #define RF_FRFLSB_928             0x00 
....................  
....................  
.................... // RegOsc1 
.................... #define RF_OSC1_RCCAL_START       0x80 
.................... #define RF_OSC1_RCCAL_DONE        0x40 
....................  
....................  
.................... // RegAfcCtrl 
.................... #define RF_AFCCTRL_LOWBETA_OFF    0x00  // Default 
.................... #define RF_AFCCTRL_LOWBETA_ON     0x20 
....................  
....................  
.................... // RegLowBat 
.................... #define RF_LOWBAT_MONITOR         0x10 
.................... #define RF_LOWBAT_ON              0x08 
.................... #define RF_LOWBAT_OFF             0x00  // Default 
....................  
.................... #define RF_LOWBAT_TRIM_1695       0x00 
.................... #define RF_LOWBAT_TRIM_1764       0x01 
.................... #define RF_LOWBAT_TRIM_1835       0x02  // Default 
.................... #define RF_LOWBAT_TRIM_1905       0x03 
.................... #define RF_LOWBAT_TRIM_1976       0x04 
.................... #define RF_LOWBAT_TRIM_2045       0x05 
.................... #define RF_LOWBAT_TRIM_2116       0x06 
.................... #define RF_LOWBAT_TRIM_2185       0x07 
....................  
....................  
.................... // RegListen1 
.................... #define RF_LISTEN1_RESOL_64       0x50 
.................... #define RF_LISTEN1_RESOL_4100     0xA0  // Default 
.................... #define RF_LISTEN1_RESOL_262000   0xF0 
....................  
.................... #define RF_LISTEN1_RESOL_IDLE_64     0x40 
.................... #define RF_LISTEN1_RESOL_IDLE_4100   0x80  // Default 
.................... #define RF_LISTEN1_RESOL_IDLE_262000 0xC0 
....................  
.................... #define RF_LISTEN1_RESOL_RX_64       0x10 
.................... #define RF_LISTEN1_RESOL_RX_4100     0x20  // Default 
.................... #define RF_LISTEN1_RESOL_RX_262000   0x30 
....................  
.................... #define RF_LISTEN1_CRITERIA_RSSI          0x00  // Default 
.................... #define RF_LISTEN1_CRITERIA_RSSIANDSYNC   0x08 
....................  
.................... #define RF_LISTEN1_END_00                 0x00 
.................... #define RF_LISTEN1_END_01                 0x02  // Default 
.................... #define RF_LISTEN1_END_10                 0x04 
....................  
....................  
.................... // RegListen2 
.................... #define RF_LISTEN2_COEFIDLE_VALUE         0xF5 // Default 
....................  
....................  
.................... // RegListen3 
.................... #define RF_LISTEN3_COEFRX_VALUE           0x20 // Default 
....................  
....................  
.................... // RegVersion 
.................... #define RF_VERSION_VER        0x24  // Default 
....................  
....................  
.................... // RegPaLevel 
.................... #define RF_PALEVEL_PA0_ON     0x80  // Default 
.................... #define RF_PALEVEL_PA0_OFF    0x00 
.................... #define RF_PALEVEL_PA1_ON     0x40 
.................... #define RF_PALEVEL_PA1_OFF    0x00  // Default 
.................... #define RF_PALEVEL_PA2_ON     0x20 
.................... #define RF_PALEVEL_PA2_OFF    0x00  // Default 
....................  
.................... #define RF_PALEVEL_OUTPUTPOWER_00000      0x00 
.................... #define RF_PALEVEL_OUTPUTPOWER_00001      0x01 
.................... #define RF_PALEVEL_OUTPUTPOWER_00010      0x02 
.................... #define RF_PALEVEL_OUTPUTPOWER_00011      0x03 
.................... #define RF_PALEVEL_OUTPUTPOWER_00100      0x04 
.................... #define RF_PALEVEL_OUTPUTPOWER_00101      0x05 
.................... #define RF_PALEVEL_OUTPUTPOWER_00110      0x06 
.................... #define RF_PALEVEL_OUTPUTPOWER_00111      0x07 
.................... #define RF_PALEVEL_OUTPUTPOWER_01000      0x08 
.................... #define RF_PALEVEL_OUTPUTPOWER_01001      0x09 
.................... #define RF_PALEVEL_OUTPUTPOWER_01010      0x0A 
.................... #define RF_PALEVEL_OUTPUTPOWER_01011      0x0B 
.................... #define RF_PALEVEL_OUTPUTPOWER_01100      0x0C 
.................... #define RF_PALEVEL_OUTPUTPOWER_01101      0x0D 
.................... #define RF_PALEVEL_OUTPUTPOWER_01110      0x0E 
.................... #define RF_PALEVEL_OUTPUTPOWER_01111      0x0F 
.................... #define RF_PALEVEL_OUTPUTPOWER_10000      0x10 
.................... #define RF_PALEVEL_OUTPUTPOWER_10001      0x11 
.................... #define RF_PALEVEL_OUTPUTPOWER_10010      0x12 
.................... #define RF_PALEVEL_OUTPUTPOWER_10011      0x13 
.................... #define RF_PALEVEL_OUTPUTPOWER_10100      0x14 
.................... #define RF_PALEVEL_OUTPUTPOWER_10101      0x15 
.................... #define RF_PALEVEL_OUTPUTPOWER_10110      0x16 
.................... #define RF_PALEVEL_OUTPUTPOWER_10111      0x17 
.................... #define RF_PALEVEL_OUTPUTPOWER_11000      0x18 
.................... #define RF_PALEVEL_OUTPUTPOWER_11001      0x19 
.................... #define RF_PALEVEL_OUTPUTPOWER_11010      0x1A 
.................... #define RF_PALEVEL_OUTPUTPOWER_11011      0x1B 
.................... #define RF_PALEVEL_OUTPUTPOWER_11100      0x1C 
.................... #define RF_PALEVEL_OUTPUTPOWER_11101      0x1D 
.................... #define RF_PALEVEL_OUTPUTPOWER_11110      0x1E 
.................... #define RF_PALEVEL_OUTPUTPOWER_11111      0x1F  // Default 
....................  
....................  
.................... // RegPaRamp 
.................... #define RF_PARAMP_3400            0x00 
.................... #define RF_PARAMP_2000            0x01 
.................... #define RF_PARAMP_1000            0x02 
.................... #define RF_PARAMP_500             0x03 
.................... #define RF_PARAMP_250             0x04 
.................... #define RF_PARAMP_125             0x05 
.................... #define RF_PARAMP_100             0x06 
.................... #define RF_PARAMP_62              0x07 
.................... #define RF_PARAMP_50              0x08 
.................... #define RF_PARAMP_40              0x09  // Default 
.................... #define RF_PARAMP_31              0x0A 
.................... #define RF_PARAMP_25              0x0B 
.................... #define RF_PARAMP_20              0x0C 
.................... #define RF_PARAMP_15              0x0D 
.................... #define RF_PARAMP_12              0x0E 
.................... #define RF_PARAMP_10              0x0F 
....................  
....................  
.................... // RegOcp 
.................... #define RF_OCP_OFF                0x0F 
.................... #define RF_OCP_ON                 0x1A  // Default 
....................  
.................... #define RF_OCP_TRIM_45            0x00 
.................... #define RF_OCP_TRIM_50            0x01 
.................... #define RF_OCP_TRIM_55            0x02 
.................... #define RF_OCP_TRIM_60            0x03 
.................... #define RF_OCP_TRIM_65            0x04 
.................... #define RF_OCP_TRIM_70            0x05 
.................... #define RF_OCP_TRIM_75            0x06 
.................... #define RF_OCP_TRIM_80            0x07 
.................... #define RF_OCP_TRIM_85            0x08 
.................... #define RF_OCP_TRIM_90            0x09 
.................... #define RF_OCP_TRIM_95            0x0A  // Default 
.................... #define RF_OCP_TRIM_100           0x0B 
.................... #define RF_OCP_TRIM_105           0x0C 
.................... #define RF_OCP_TRIM_110           0x0D 
.................... #define RF_OCP_TRIM_115           0x0E 
.................... #define RF_OCP_TRIM_120           0x0F 
....................  
....................  
.................... // RegAgcRef - not present on RFM69/SX1231 
.................... #define RF_AGCREF_AUTO_ON         0x40  // Default 
.................... #define RF_AGCREF_AUTO_OFF        0x00 
....................  
.................... #define RF_AGCREF_LEVEL_MINUS80   0x00  // Default 
.................... #define RF_AGCREF_LEVEL_MINUS81   0x01 
.................... #define RF_AGCREF_LEVEL_MINUS82   0x02 
.................... #define RF_AGCREF_LEVEL_MINUS83   0x03 
.................... #define RF_AGCREF_LEVEL_MINUS84   0x04 
.................... #define RF_AGCREF_LEVEL_MINUS85   0x05 
.................... #define RF_AGCREF_LEVEL_MINUS86   0x06 
.................... #define RF_AGCREF_LEVEL_MINUS87   0x07 
.................... #define RF_AGCREF_LEVEL_MINUS88   0x08 
.................... #define RF_AGCREF_LEVEL_MINUS89   0x09 
.................... #define RF_AGCREF_LEVEL_MINUS90   0x0A 
.................... #define RF_AGCREF_LEVEL_MINUS91   0x0B 
.................... #define RF_AGCREF_LEVEL_MINUS92   0x0C 
.................... #define RF_AGCREF_LEVEL_MINUS93   0x0D 
.................... #define RF_AGCREF_LEVEL_MINUS94   0x0E 
.................... #define RF_AGCREF_LEVEL_MINUS95   0x0F 
.................... #define RF_AGCREF_LEVEL_MINUS96   0x10 
.................... #define RF_AGCREF_LEVEL_MINUS97   0x11 
.................... #define RF_AGCREF_LEVEL_MINUS98   0x12 
.................... #define RF_AGCREF_LEVEL_MINUS99   0x13 
.................... #define RF_AGCREF_LEVEL_MINUS100  0x14 
.................... #define RF_AGCREF_LEVEL_MINUS101  0x15 
.................... #define RF_AGCREF_LEVEL_MINUS102  0x16 
.................... #define RF_AGCREF_LEVEL_MINUS103  0x17 
.................... #define RF_AGCREF_LEVEL_MINUS104  0x18 
.................... #define RF_AGCREF_LEVEL_MINUS105  0x19 
.................... #define RF_AGCREF_LEVEL_MINUS106  0x1A 
.................... #define RF_AGCREF_LEVEL_MINUS107  0x1B 
.................... #define RF_AGCREF_LEVEL_MINUS108  0x1C 
.................... #define RF_AGCREF_LEVEL_MINUS109  0x1D 
.................... #define RF_AGCREF_LEVEL_MINUS110  0x1E 
.................... #define RF_AGCREF_LEVEL_MINUS111  0x1F 
.................... #define RF_AGCREF_LEVEL_MINUS112  0x20 
.................... #define RF_AGCREF_LEVEL_MINUS113  0x21 
.................... #define RF_AGCREF_LEVEL_MINUS114  0x22 
.................... #define RF_AGCREF_LEVEL_MINUS115  0x23 
.................... #define RF_AGCREF_LEVEL_MINUS116  0x24 
.................... #define RF_AGCREF_LEVEL_MINUS117  0x25 
.................... #define RF_AGCREF_LEVEL_MINUS118  0x26 
.................... #define RF_AGCREF_LEVEL_MINUS119  0x27 
.................... #define RF_AGCREF_LEVEL_MINUS120  0x28 
.................... #define RF_AGCREF_LEVEL_MINUS121  0x29 
.................... #define RF_AGCREF_LEVEL_MINUS122  0x2A 
.................... #define RF_AGCREF_LEVEL_MINUS123  0x2B 
.................... #define RF_AGCREF_LEVEL_MINUS124  0x2C 
.................... #define RF_AGCREF_LEVEL_MINUS125  0x2D 
.................... #define RF_AGCREF_LEVEL_MINUS126  0x2E 
.................... #define RF_AGCREF_LEVEL_MINUS127  0x2F 
.................... #define RF_AGCREF_LEVEL_MINUS128  0x30 
.................... #define RF_AGCREF_LEVEL_MINUS129  0x31 
.................... #define RF_AGCREF_LEVEL_MINUS130  0x32 
.................... #define RF_AGCREF_LEVEL_MINUS131  0x33 
.................... #define RF_AGCREF_LEVEL_MINUS132  0x34 
.................... #define RF_AGCREF_LEVEL_MINUS133  0x35 
.................... #define RF_AGCREF_LEVEL_MINUS134  0x36 
.................... #define RF_AGCREF_LEVEL_MINUS135  0x37 
.................... #define RF_AGCREF_LEVEL_MINUS136  0x38 
.................... #define RF_AGCREF_LEVEL_MINUS137  0x39 
.................... #define RF_AGCREF_LEVEL_MINUS138  0x3A 
.................... #define RF_AGCREF_LEVEL_MINUS139  0x3B 
.................... #define RF_AGCREF_LEVEL_MINUS140  0x3C 
.................... #define RF_AGCREF_LEVEL_MINUS141  0x3D 
.................... #define RF_AGCREF_LEVEL_MINUS142  0x3E 
.................... #define RF_AGCREF_LEVEL_MINUS143  0x3F 
....................  
....................  
.................... // RegAgcThresh1 - not present on RFM69/SX1231 
.................... #define RF_AGCTHRESH1_SNRMARGIN_000   0x00 
.................... #define RF_AGCTHRESH1_SNRMARGIN_001   0x20 
.................... #define RF_AGCTHRESH1_SNRMARGIN_010   0x40 
.................... #define RF_AGCTHRESH1_SNRMARGIN_011   0x60 
.................... #define RF_AGCTHRESH1_SNRMARGIN_100   0x80 
.................... #define RF_AGCTHRESH1_SNRMARGIN_101   0xA0  // Default 
.................... #define RF_AGCTHRESH1_SNRMARGIN_110   0xC0 
.................... #define RF_AGCTHRESH1_SNRMARGIN_111   0xE0 
....................  
.................... #define RF_AGCTHRESH1_STEP1_0         0x00 
.................... #define RF_AGCTHRESH1_STEP1_1         0x01 
.................... #define RF_AGCTHRESH1_STEP1_2         0x02 
.................... #define RF_AGCTHRESH1_STEP1_3         0x03 
.................... #define RF_AGCTHRESH1_STEP1_4         0x04 
.................... #define RF_AGCTHRESH1_STEP1_5         0x05 
.................... #define RF_AGCTHRESH1_STEP1_6         0x06 
.................... #define RF_AGCTHRESH1_STEP1_7         0x07 
.................... #define RF_AGCTHRESH1_STEP1_8         0x08 
.................... #define RF_AGCTHRESH1_STEP1_9         0x09 
.................... #define RF_AGCTHRESH1_STEP1_10        0x0A 
.................... #define RF_AGCTHRESH1_STEP1_11        0x0B 
.................... #define RF_AGCTHRESH1_STEP1_12        0x0C 
.................... #define RF_AGCTHRESH1_STEP1_13        0x0D 
.................... #define RF_AGCTHRESH1_STEP1_14        0x0E 
.................... #define RF_AGCTHRESH1_STEP1_15        0x0F 
.................... #define RF_AGCTHRESH1_STEP1_16        0x10  // Default 
.................... #define RF_AGCTHRESH1_STEP1_17        0x11 
.................... #define RF_AGCTHRESH1_STEP1_18        0x12 
.................... #define RF_AGCTHRESH1_STEP1_19        0x13 
.................... #define RF_AGCTHRESH1_STEP1_20        0x14 
.................... #define RF_AGCTHRESH1_STEP1_21        0x15 
.................... #define RF_AGCTHRESH1_STEP1_22        0x16 
.................... #define RF_AGCTHRESH1_STEP1_23        0x17 
.................... #define RF_AGCTHRESH1_STEP1_24        0x18 
.................... #define RF_AGCTHRESH1_STEP1_25        0x19 
.................... #define RF_AGCTHRESH1_STEP1_26        0x1A 
.................... #define RF_AGCTHRESH1_STEP1_27        0x1B 
.................... #define RF_AGCTHRESH1_STEP1_28        0x1C 
.................... #define RF_AGCTHRESH1_STEP1_29        0x1D 
.................... #define RF_AGCTHRESH1_STEP1_30        0x1E 
.................... #define RF_AGCTHRESH1_STEP1_31        0x1F 
....................  
....................  
.................... // RegAgcThresh2 - not present on RFM69/SX1231 
.................... #define RF_AGCTHRESH2_STEP2_0         0x00 
.................... #define RF_AGCTHRESH2_STEP2_1         0x10 
.................... #define RF_AGCTHRESH2_STEP2_2         0x20 
.................... #define RF_AGCTHRESH2_STEP2_3         0x30  // XXX wrong -- Default 
.................... #define RF_AGCTHRESH2_STEP2_4         0x40 
.................... #define RF_AGCTHRESH2_STEP2_5         0x50 
.................... #define RF_AGCTHRESH2_STEP2_6         0x60 
.................... #define RF_AGCTHRESH2_STEP2_7         0x70  // default 
.................... #define RF_AGCTHRESH2_STEP2_8         0x80 
.................... #define RF_AGCTHRESH2_STEP2_9         0x90 
.................... #define RF_AGCTHRESH2_STEP2_10        0xA0 
.................... #define RF_AGCTHRESH2_STEP2_11        0xB0 
.................... #define RF_AGCTHRESH2_STEP2_12        0xC0 
.................... #define RF_AGCTHRESH2_STEP2_13        0xD0 
.................... #define RF_AGCTHRESH2_STEP2_14        0xE0 
.................... #define RF_AGCTHRESH2_STEP2_15        0xF0 
....................  
.................... #define RF_AGCTHRESH2_STEP3_0         0x00 
.................... #define RF_AGCTHRESH2_STEP3_1         0x01 
.................... #define RF_AGCTHRESH2_STEP3_2         0x02 
.................... #define RF_AGCTHRESH2_STEP3_3         0x03 
.................... #define RF_AGCTHRESH2_STEP3_4         0x04 
.................... #define RF_AGCTHRESH2_STEP3_5         0x05 
.................... #define RF_AGCTHRESH2_STEP3_6         0x06 
.................... #define RF_AGCTHRESH2_STEP3_7         0x07 
.................... #define RF_AGCTHRESH2_STEP3_8         0x08 
.................... #define RF_AGCTHRESH2_STEP3_9         0x09 
.................... #define RF_AGCTHRESH2_STEP3_10        0x0A 
.................... #define RF_AGCTHRESH2_STEP3_11        0x0B  // Default 
.................... #define RF_AGCTHRESH2_STEP3_12        0x0C 
.................... #define RF_AGCTHRESH2_STEP3_13        0x0D 
.................... #define RF_AGCTHRESH2_STEP3_14        0x0E 
.................... #define RF_AGCTHRESH2_STEP3_15        0x0F 
....................  
....................  
.................... // RegAgcThresh3 - not present on RFM69/SX1231 
.................... #define RF_AGCTHRESH3_STEP4_0         0x00 
.................... #define RF_AGCTHRESH3_STEP4_1         0x10 
.................... #define RF_AGCTHRESH3_STEP4_2         0x20 
.................... #define RF_AGCTHRESH3_STEP4_3         0x30 
.................... #define RF_AGCTHRESH3_STEP4_4         0x40 
.................... #define RF_AGCTHRESH3_STEP4_5         0x50 
.................... #define RF_AGCTHRESH3_STEP4_6         0x60 
.................... #define RF_AGCTHRESH3_STEP4_7         0x70 
.................... #define RF_AGCTHRESH3_STEP4_8         0x80 
.................... #define RF_AGCTHRESH3_STEP4_9         0x90  // Default 
.................... #define RF_AGCTHRESH3_STEP4_10        0xA0 
.................... #define RF_AGCTHRESH3_STEP4_11        0xB0 
.................... #define RF_AGCTHRESH3_STEP4_12        0xC0 
.................... #define RF_AGCTHRESH3_STEP4_13        0xD0 
.................... #define RF_AGCTHRESH3_STEP4_14        0xE0 
.................... #define RF_AGCTHRESH3_STEP4_15        0xF0 
....................  
.................... #define RF_AGCTHRESH3_STEP5_0         0x00 
.................... #define RF_AGCTHRESH3_STEP5_1         0x01 
.................... #define RF_AGCTHRESH3_STEP5_2         0x02 
.................... #define RF_AGCTHRESH3_STEP5_3         0x03 
.................... #define RF_AGCTHRESH3_STEP5_4         0x04 
.................... #define RF_AGCTHRESH3_STEP5_5         0x05 
.................... #define RF_AGCTHRESH3_STEP5_6         0x06 
.................... #define RF_AGCTHRESH3_STEP5_7         0x07 
.................... #define RF_AGCTHRES33_STEP5_8         0x08 
.................... #define RF_AGCTHRESH3_STEP5_9         0x09 
.................... #define RF_AGCTHRESH3_STEP5_10        0x0A 
.................... #define RF_AGCTHRESH3_STEP5_11        0x0B  // Default 
.................... #define RF_AGCTHRESH3_STEP5_12        0x0C 
.................... #define RF_AGCTHRESH3_STEP5_13        0x0D 
.................... #define RF_AGCTHRESH3_STEP5_14        0x0E 
.................... #define RF_AGCTHRESH3_STEP5_15        0x0F 
....................  
....................  
.................... // RegLna 
.................... #define RF_LNA_ZIN_50                 0x00  // Reset value 
.................... #define RF_LNA_ZIN_200                0x80  // Recommended default 
....................  
.................... #define RF_LNA_LOWPOWER_OFF           0x00  // Default 
.................... #define RF_LNA_LOWPOWER_ON            0x40 
....................  
.................... #define RF_LNA_CURRENTGAIN            0x08 
....................  
.................... #define RF_LNA_GAINSELECT_AUTO        0x00  // Default 
.................... #define RF_LNA_GAINSELECT_MAX         0x01 
.................... #define RF_LNA_GAINSELECT_MAXMINUS6   0x02 
.................... #define RF_LNA_GAINSELECT_MAXMINUS12  0x03 
.................... #define RF_LNA_GAINSELECT_MAXMINUS24  0x04 
.................... #define RF_LNA_GAINSELECT_MAXMINUS36  0x05 
.................... #define RF_LNA_GAINSELECT_MAXMINUS48  0x06 
....................  
....................  
.................... // RegRxBw 
.................... #define RF_RXBW_DCCFREQ_000           0x00 
.................... #define RF_RXBW_DCCFREQ_001           0x20 
.................... #define RF_RXBW_DCCFREQ_010           0x40  // Recommended default 
.................... #define RF_RXBW_DCCFREQ_011           0x60 
.................... #define RF_RXBW_DCCFREQ_100           0x80  // Reset value 
.................... #define RF_RXBW_DCCFREQ_101           0xA0 
.................... #define RF_RXBW_DCCFREQ_110           0xC0 
.................... #define RF_RXBW_DCCFREQ_111           0xE0 
....................  
.................... #define RF_RXBW_MANT_16               0x00  // Reset value 
.................... #define RF_RXBW_MANT_20               0x08 
.................... #define RF_RXBW_MANT_24               0x10  // Recommended default 
....................  
.................... #define RF_RXBW_EXP_0                 0x00 
.................... #define RF_RXBW_EXP_1                 0x01 
.................... #define RF_RXBW_EXP_2                 0x02 
.................... #define RF_RXBW_EXP_3                 0x03 
.................... #define RF_RXBW_EXP_4                 0x04 
.................... #define RF_RXBW_EXP_5                 0x05  // Recommended default 
.................... #define RF_RXBW_EXP_6                 0x06  // Reset value 
.................... #define RF_RXBW_EXP_7                 0x07 
....................  
....................  
.................... // RegAfcBw 
.................... #define RF_AFCBW_DCCFREQAFC_000       0x00 
.................... #define RF_AFCBW_DCCFREQAFC_001       0x20 
.................... #define RF_AFCBW_DCCFREQAFC_010       0x40 
.................... #define RF_AFCBW_DCCFREQAFC_011       0x60 
.................... #define RF_AFCBW_DCCFREQAFC_100       0x80  // Default 
.................... #define RF_AFCBW_DCCFREQAFC_101       0xA0 
.................... #define RF_AFCBW_DCCFREQAFC_110       0xC0 
.................... #define RF_AFCBW_DCCFREQAFC_111       0xE0 
....................  
.................... #define RF_AFCBW_MANTAFC_16           0x00 
.................... #define RF_AFCBW_MANTAFC_20           0x08  // Default 
.................... #define RF_AFCBW_MANTAFC_24           0x10 
....................  
.................... #define RF_AFCBW_EXPAFC_0             0x00 
.................... #define RF_AFCBW_EXPAFC_1             0x01 
.................... #define RF_AFCBW_EXPAFC_2             0x02  // Reset value 
.................... #define RF_AFCBW_EXPAFC_3             0x03  // Recommended default 
.................... #define RF_AFCBW_EXPAFC_4             0x04 
.................... #define RF_AFCBW_EXPAFC_5             0x05 
.................... #define RF_AFCBW_EXPAFC_6             0x06 
.................... #define RF_AFCBW_EXPAFC_7             0x07 
....................  
....................  
.................... // RegOokPeak 
.................... #define RF_OOKPEAK_THRESHTYPE_FIXED       0x00 
.................... #define RF_OOKPEAK_THRESHTYPE_PEAK        0x40  // Default 
.................... #define RF_OOKPEAK_THRESHTYPE_AVERAGE     0x80 
....................  
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_000     0x00  // Default 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_001     0x08 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_010     0x10 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_011     0x18 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_100     0x20 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_101     0x28 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_110     0x30 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_111     0x38 
....................  
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_000      0x00  // Default 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_001      0x01 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_010      0x02 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_011      0x03 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_100      0x04 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_101      0x05 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_110      0x06 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_111      0x07 
....................  
....................  
.................... // RegOokAvg 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_00    0x00 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_01    0x40 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_10    0x80  // Default 
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_11    0xC0 
....................  
....................  
.................... // RegOokFix 
.................... #define RF_OOKFIX_FIXEDTHRESH_VALUE       0x06  // Default 
....................  
....................  
.................... // RegAfcFei 
.................... #define RF_AFCFEI_FEI_DONE                0x40 
.................... #define RF_AFCFEI_FEI_START               0x20 
.................... #define RF_AFCFEI_AFC_DONE                0x10 
.................... #define RF_AFCFEI_AFCAUTOCLEAR_ON         0x08 
.................... #define RF_AFCFEI_AFCAUTOCLEAR_OFF        0x00  // Default 
....................  
.................... #define RF_AFCFEI_AFCAUTO_ON              0x04 
.................... #define RF_AFCFEI_AFCAUTO_OFF             0x00  // Default 
....................  
.................... #define RF_AFCFEI_AFC_CLEAR               0x02 
.................... #define RF_AFCFEI_AFC_START               0x01 
....................  
....................  
.................... // RegRssiConfig 
.................... #define RF_RSSI_FASTRX_ON                 0x08  // not present on RFM69/SX1231 
.................... #define RF_RSSI_FASTRX_OFF                0x00  // Default 
....................  
.................... #define RF_RSSI_DONE                      0x02 
.................... #define RF_RSSI_START                     0x01 
....................  
....................  
.................... // RegDioMapping1 
.................... #define RF_DIOMAPPING1_DIO0_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO0_01            0x40 
.................... #define RF_DIOMAPPING1_DIO0_10            0x80 
.................... #define RF_DIOMAPPING1_DIO0_11            0xC0 
....................  
.................... #define RF_DIOMAPPING1_DIO1_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO1_01            0x10 
.................... #define RF_DIOMAPPING1_DIO1_10            0x20 
.................... #define RF_DIOMAPPING1_DIO1_11            0x30 
....................  
.................... #define RF_DIOMAPPING1_DIO2_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO2_01            0x04 
.................... #define RF_DIOMAPPING1_DIO2_10            0x08 
.................... #define RF_DIOMAPPING1_DIO2_11            0x0C 
....................  
.................... #define RF_DIOMAPPING1_DIO3_00            0x00  // Default 
.................... #define RF_DIOMAPPING1_DIO3_01            0x01 
.................... #define RF_DIOMAPPING1_DIO3_10            0x02 
.................... #define RF_DIOMAPPING1_DIO3_11            0x03 
....................  
....................  
.................... // RegDioMapping2 
.................... #define RF_DIOMAPPING2_DIO4_00            0x00  // Default 
.................... #define RF_DIOMAPPING2_DIO4_01            0x40 
.................... #define RF_DIOMAPPING2_DIO4_10            0x80 
.................... #define RF_DIOMAPPING2_DIO4_11            0xC0 
....................  
.................... #define RF_DIOMAPPING2_DIO5_00            0x00  // Default 
.................... #define RF_DIOMAPPING2_DIO5_01            0x10 
.................... #define RF_DIOMAPPING2_DIO5_10            0x20 
.................... #define RF_DIOMAPPING2_DIO5_11            0x30 
....................  
.................... #define RF_DIOMAPPING2_CLKOUT_32MHZ       0x00 
.................... #define RF_DIOMAPPING2_CLKOUT_16MHZ       0x01 
.................... #define RF_DIOMAPPING2_CLKOUT_8MHZ        0x02 
.................... #define RF_DIOMAPPING2_CLKOUT_4MHZ        0x03 
.................... #define RF_DIOMAPPING2_CLKOUT_2MHZ        0x04 
.................... #define RF_DIOMAPPING2_CLKOUT_1MHZ        0x05  // Reset value 
.................... #define RF_DIOMAPPING2_CLKOUT_RC          0x06 
.................... #define RF_DIOMAPPING2_CLKOUT_OFF         0x07  // Recommended default 
....................  
....................  
.................... // RegIrqFlags1 
.................... #define RF_IRQFLAGS1_MODEREADY            0x80 
.................... #define RF_IRQFLAGS1_RXREADY              0x40 
.................... #define RF_IRQFLAGS1_TXREADY              0x20 
.................... #define RF_IRQFLAGS1_PLLLOCK              0x10 
.................... #define RF_IRQFLAGS1_RSSI                 0x08 
.................... #define RF_IRQFLAGS1_TIMEOUT              0x04 
.................... #define RF_IRQFLAGS1_AUTOMODE             0x02 
.................... #define RF_IRQFLAGS1_SYNCADDRESSMATCH     0x01 
....................  
....................  
.................... // RegIrqFlags2 
.................... #define RF_IRQFLAGS2_FIFOFULL             0x80 
.................... #define RF_IRQFLAGS2_FIFONOTEMPTY         0x40 
.................... #define RF_IRQFLAGS2_FIFOLEVEL            0x20 
.................... #define RF_IRQFLAGS2_FIFOOVERRUN          0x10 
.................... #define RF_IRQFLAGS2_PACKETSENT           0x08 
.................... #define RF_IRQFLAGS2_PAYLOADREADY         0x04 
.................... #define RF_IRQFLAGS2_CRCOK                0x02 
.................... #define RF_IRQFLAGS2_LOWBAT               0x01  // not present on RFM69/SX1231 
....................  
....................  
.................... // RegRssiThresh 
.................... #define RF_RSSITHRESH_VALUE               0xE4  // Default 
....................  
....................  
.................... // RegRxTimeout1 
.................... #define RF_RXTIMEOUT1_RXSTART_VALUE       0x00  // Default 
....................  
....................  
.................... // RegRxTimeout2 
.................... #define RF_RXTIMEOUT2_RSSITHRESH_VALUE    0x00  // Default 
....................  
....................  
.................... // RegPreamble 
.................... #define RF_PREAMBLESIZE_MSB_VALUE         0x00  // Default 
.................... #define RF_PREAMBLESIZE_LSB_VALUE         0x03  // Default 
....................  
....................  
.................... // RegSyncConfig 
.................... #define RF_SYNC_ON                0x80  // Default 
.................... #define RF_SYNC_OFF               0x00 
....................  
.................... #define RF_SYNC_FIFOFILL_AUTO     0x00  // Default -- when sync interrupt occurs 
.................... #define RF_SYNC_FIFOFILL_MANUAL   0x40 
....................  
.................... #define RF_SYNC_SIZE_1            0x00 
.................... #define RF_SYNC_SIZE_2            0x08 
.................... #define RF_SYNC_SIZE_3            0x10 
.................... #define RF_SYNC_SIZE_4            0x18  // Default 
.................... #define RF_SYNC_SIZE_5            0x20 
.................... #define RF_SYNC_SIZE_6            0x28 
.................... #define RF_SYNC_SIZE_7            0x30 
.................... #define RF_SYNC_SIZE_8            0x38 
....................  
.................... #define RF_SYNC_TOL_0             0x00  // Default 
.................... #define RF_SYNC_TOL_1             0x01 
.................... #define RF_SYNC_TOL_2             0x02 
.................... #define RF_SYNC_TOL_3             0x03 
.................... #define RF_SYNC_TOL_4             0x04 
.................... #define RF_SYNC_TOL_5             0x05 
.................... #define RF_SYNC_TOL_6             0x06 
.................... #define RF_SYNC_TOL_7             0x07 
....................  
....................  
.................... // RegSyncValue1-8 
.................... #define RF_SYNC_BYTE1_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE2_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE3_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE4_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE5_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE6_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE7_VALUE       0x00  // Default 
.................... #define RF_SYNC_BYTE8_VALUE       0x00  // Default 
....................  
....................  
.................... // RegPacketConfig1 
.................... #define RF_PACKET1_FORMAT_FIXED       0x00  // Default 
.................... #define RF_PACKET1_FORMAT_VARIABLE    0x80 
....................  
.................... #define RF_PACKET1_DCFREE_OFF         0x00  // Default 
.................... #define RF_PACKET1_DCFREE_MANCHESTER  0x20 
.................... #define RF_PACKET1_DCFREE_WHITENING   0x40 
....................  
.................... #define RF_PACKET1_CRC_ON             0x10  // Default 
.................... #define RF_PACKET1_CRC_OFF            0x00 
....................  
.................... #define RF_PACKET1_CRCAUTOCLEAR_ON    0x00  // Default 
.................... #define RF_PACKET1_CRCAUTOCLEAR_OFF   0x08 
....................  
.................... #define RF_PACKET1_ADRSFILTERING_OFF            0x00  // Default 
.................... #define RF_PACKET1_ADRSFILTERING_NODE           0x02 
.................... #define RF_PACKET1_ADRSFILTERING_NODEBROADCAST  0x04 
....................  
....................  
.................... // RegPayloadLength 
.................... #define RF_PAYLOADLENGTH_VALUE          0x40  // Default 
....................  
....................  
.................... // RegBroadcastAdrs 
.................... #define RF_BROADCASTADDRESS_VALUE       0x00 
....................  
....................  
.................... // RegAutoModes 
.................... #define RF_AUTOMODES_ENTER_OFF                0x00  // Default 
.................... #define RF_AUTOMODES_ENTER_FIFONOTEMPTY       0x20 
.................... #define RF_AUTOMODES_ENTER_FIFOLEVEL          0x40 
.................... #define RF_AUTOMODES_ENTER_CRCOK              0x60 
.................... #define RF_AUTOMODES_ENTER_PAYLOADREADY       0x80 
.................... #define RF_AUTOMODES_ENTER_SYNCADRSMATCH      0xA0 
.................... #define RF_AUTOMODES_ENTER_PACKETSENT         0xC0 
.................... #define RF_AUTOMODES_ENTER_FIFOEMPTY          0xE0 
....................  
.................... #define RF_AUTOMODES_EXIT_OFF                 0x00  // Default 
.................... #define RF_AUTOMODES_EXIT_FIFOEMPTY           0x04 
.................... #define RF_AUTOMODES_EXIT_FIFOLEVEL           0x08 
.................... #define RF_AUTOMODES_EXIT_CRCOK               0x0C 
.................... #define RF_AUTOMODES_EXIT_PAYLOADREADY        0x10 
.................... #define RF_AUTOMODES_EXIT_SYNCADRSMATCH       0x14 
.................... #define RF_AUTOMODES_EXIT_PACKETSENT          0x18 
.................... #define RF_AUTOMODES_EXIT_RXTIMEOUT           0x1C 
....................  
.................... #define RF_AUTOMODES_INTERMEDIATE_SLEEP       0x00  // Default 
.................... #define RF_AUTOMODES_INTERMEDIATE_STANDBY     0x01 
.................... #define RF_AUTOMODES_INTERMEDIATE_RECEIVER    0x02 
.................... #define RF_AUTOMODES_INTERMEDIATE_TRANSMITTER 0x03 
....................  
....................  
.................... // RegFifoThresh 
.................... #define RF_FIFOTHRESH_TXSTART_FIFOTHRESH      0x00  // Reset value 
.................... #define RF_FIFOTHRESH_TXSTART_FIFONOTEMPTY    0x80  // Recommended default 
....................  
.................... #define RF_FIFOTHRESH_VALUE                   0x0F  // Default 
....................  
....................  
.................... // RegPacketConfig2 
.................... #define RF_PACKET2_RXRESTARTDELAY_1BIT        0x00  // Default 
.................... #define RF_PACKET2_RXRESTARTDELAY_2BITS       0x10 
.................... #define RF_PACKET2_RXRESTARTDELAY_4BITS       0x20 
.................... #define RF_PACKET2_RXRESTARTDELAY_8BITS       0x30 
.................... #define RF_PACKET2_RXRESTARTDELAY_16BITS      0x40 
.................... #define RF_PACKET2_RXRESTARTDELAY_32BITS      0x50 
.................... #define RF_PACKET2_RXRESTARTDELAY_64BITS      0x60 
.................... #define RF_PACKET2_RXRESTARTDELAY_128BITS     0x70 
.................... #define RF_PACKET2_RXRESTARTDELAY_256BITS     0x80 
.................... #define RF_PACKET2_RXRESTARTDELAY_512BITS     0x90 
.................... #define RF_PACKET2_RXRESTARTDELAY_1024BITS    0xA0 
.................... #define RF_PACKET2_RXRESTARTDELAY_2048BITS    0xB0 
.................... #define RF_PACKET2_RXRESTARTDELAY_NONE        0xC0 
.................... #define RF_PACKET2_RXRESTART                  0x04 
....................  
.................... #define RF_PACKET2_AUTORXRESTART_ON           0x02  // Default 
.................... #define RF_PACKET2_AUTORXRESTART_OFF          0x00 
....................  
.................... #define RF_PACKET2_AES_ON                     0x01 
.................... #define RF_PACKET2_AES_OFF                    0x00  // Default 
....................  
....................  
.................... // RegAesKey1-16 
.................... #define RF_AESKEY1_VALUE            0x00  // Default 
.................... #define RF_AESKEY2_VALUE            0x00  // Default 
.................... #define RF_AESKEY3_VALUE            0x00  // Default 
.................... #define RF_AESKEY4_VALUE            0x00  // Default 
.................... #define RF_AESKEY5_VALUE            0x00  // Default 
.................... #define RF_AESKEY6_VALUE            0x00  // Default 
.................... #define RF_AESKEY7_VALUE            0x00  // Default 
.................... #define RF_AESKEY8_VALUE            0x00  // Default 
.................... #define RF_AESKEY9_VALUE            0x00  // Default 
.................... #define RF_AESKEY10_VALUE           0x00  // Default 
.................... #define RF_AESKEY11_VALUE           0x00  // Default 
.................... #define RF_AESKEY12_VALUE           0x00  // Default 
.................... #define RF_AESKEY13_VALUE           0x00  // Default 
.................... #define RF_AESKEY14_VALUE           0x00  // Default 
.................... #define RF_AESKEY15_VALUE           0x00  // Default 
.................... #define RF_AESKEY16_VALUE           0x00  // Default 
....................  
....................  
.................... // RegTemp1 
.................... #define RF_TEMP1_MEAS_START         0x08 
.................... #define RF_TEMP1_MEAS_RUNNING       0x04 
.................... // not present on RFM69/SX1231 
.................... #define RF_TEMP1_ADCLOWPOWER_ON     0x01  // Default 
.................... #define RF_TEMP1_ADCLOWPOWER_OFF    0x00 
....................  
....................  
.................... // RegTestLna 
.................... #define RF_TESTLNA_NORMAL           0x1B 
.................... #define RF_TESTLNA_HIGH_SENSITIVITY 0x2D 
....................  
....................  
.................... // RegTestDagc 
.................... #define RF_DAGC_NORMAL              0x00  // Reset value 
.................... #define RF_DAGC_IMPROVED_LOWBETA1   0x20 
.................... #define RF_DAGC_IMPROVED_LOWBETA0   0x30  // Recommended default 
....................  
....................  
.................... #define RF69_MAX_DATA_LEN       61  
.................... int CSMA_LIMIT = -90; // upper RX signal sensitivity threshold in dBm for carrier sense access 
.................... #define RF69_MODE_SLEEP         0 // XTAL OFF 
.................... #define RF69_MODE_STANDBY       1 // XTAL ON 
.................... #define RF69_MODE_SYNTH         2 // PLL ON 
.................... #define RF69_MODE_RX            3 // RX MODE 
.................... #define RF69_MODE_TX            4 // TX MODE 
....................  
.................... // available frequency bands 
.................... #define RF69_315MHZ            31 // non trivial values to avoid misconfiguration 
.................... #define RF69_433MHZ            43 
.................... #define RF69_868MHZ            86 
.................... #define RF69_915MHZ            91 
....................  
.................... #define COURSE_TEMP_COEF    -90 // puts the temperature reading in the ballpark, user can fine tune the returned value 
.................... #define RF69_BROADCAST_ADDR 255 
.................... #define RF69_CSMA_LIMIT_MS 1000 
.................... #define RF69_TX_LIMIT_MS   1000 
.................... #define RF69_FSTEP  61.03515625 // == FXOSC / 2^19 = 32MHz / 2^19 (p13 in datasheet) 
....................  
.................... // TWS: define CTLbyte bits 
.................... #define RFM69_CTL_SENDACK   0x80 
.................... #define RFM69_CTL_REQACK    0x40 
....................  
....................    // static volatile int DATA[RF69_MAX_DATA_LEN]; // recv/xmit buf, including header & crc bytes 
....................     //static volatile int DATALEN; 
....................     //static volatile int SENDERID; 
....................     //static volatile int TARGETID; // should match _address 
....................     static volatile int PAYLOADLEN; 
....................     //static volatile int ACK_REQUESTED; 
....................     //static volatile int ACK_RECEIVED; // should be polled immediately after sending a packet with ACK request 
....................     static volatile int16 RSSI; // most accurate RSSI during reception (closest to the reception) 
....................     static volatile int _mode, _address;// should be protected? 
....................     short  _isRFM69HW=1; 
....................     //short  _promiscuousMode = 0; 
....................     int    _powerLevel = 31; 
....................  
....................     byte SPIRead8bit(void); 
....................     byte SPItransfer(byte WrPara); 
....................     int32 millis(); 
....................     short initialize(int8 ID); 
....................     short canSend(); 
....................     void send(int toAddress,byte* buffer, int bufferSize, short requestACK=false); 
....................     short sendWithRetry(int toAddress, byte* buffer, int bufferSize, int retries=2, int retryWaitTime=40); // 40ms roundtrip req for 61byte packets 
....................     short receiveDone(); 
....................     short ACKReceived(int fromNodeID); 
....................     short ACKRequested(); 
....................     void sendACK(byte* buffer , int bufferSize); 
....................  
....................     // allow hacking registers by making these public 
....................     int readReg(int addr); 
....................     void writeReg(int8 addr, int8 val); 
....................     void readAllRegs(); 
....................      
....................     //static volatile short _inISR; 
....................     void sendFrame(int8 toAddress, byte *buffer, int size, short requestACK=false,short sendACK=false); 
....................  
....................     void setMode(int mode); 
....................     void select(); 
....................     void unselect(); 
....................     int16 readRSSI(short forceTrigger); 
....................     void setHighPower(short onOff); 
....................     void setHighPowerRegs(short onOff); 
....................  
.................... short initialize( int nodeID) 
.................... { 
....................    const int networkID = 1; 
....................  
....................   const int8 CONFIG[][2] = 
....................   { 
....................     /* 0x01 */ { REG_OPMODE, RF_OPMODE_SEQUENCER_ON | RF_OPMODE_LISTEN_OFF | RF_OPMODE_STANDBY }, 
....................     /* 0x02 */ { REG_DATAMODUL, RF_DATAMODUL_DATAMODE_PACKET | RF_DATAMODUL_MODULATIONTYPE_FSK | RF_DATAMODUL_MODULATIONSHAPING_00 }, // no shaping 
....................     /* 0x03 */ { REG_BITRATEMSB, RF_BITRATEMSB_1200}, // default: 4.8 KBPS 
....................     /* 0x04 */ { REG_BITRATELSB, RF_BITRATELSB_1200}, 
....................     /* 0x05 */ { REG_FDEVMSB, RF_FDEVMSB_50000}, // default: 5KHz, (FDEV + BitRate / 2 <= 500KHz) 
....................     /* 0x06 */ { REG_FDEVLSB, RF_FDEVLSB_50000}, 
....................  
....................     /* 0x07 */ { REG_FRFMSB, RF_FRFMSB_915 }, 
....................     /* 0x08 */ { REG_FRFMID, RF_FRFMID_915 }, 
....................     /* 0x09 */ { REG_FRFLSB, RF_FRFLSB_915 }, 
....................  
....................     // looks like PA1 and PA2 are not implemented on RFM69W, hence the max output power is 13dBm 
....................     // +17dBm and +20dBm are possible on RFM69HW 
....................     // +13dBm formula: Pout = -18 + OutputPower (with PA0 or PA1**) 
....................     // +17dBm formula: Pout = -14 + OutputPower (with PA1 and PA2)** 
....................     // +20dBm formula: Pout = -11 + OutputPower (with PA1 and PA2)** and high power PA settings (section 3.3.7 in datasheet) 
....................     /* 0x11 */ { REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON | RF_PALEVEL_OUTPUTPOWER_11111}, 
....................     /* 0x13 */ { REG_OCP, RF_OCP_ON | RF_OCP_TRIM_95 }, // over current protection (default is 95mA) 
....................  
....................     // RXBW defaults are { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_24 | RF_RXBW_EXP_5} (RxBw: 10.4KHz) 
....................     /* 0x19 */ { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_16 | RF_RXBW_EXP_2 }, // (BitRate < 2 * RxBw) 
....................     //for BR-19200: /* 0x19 */ { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_24 | RF_RXBW_EXP_3 }, 
....................     /* 0x25 */ { REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_01 }, // DIO0 is the only IRQ we're using 
....................     /* 0x26 */ { REG_DIOMAPPING2, RF_DIOMAPPING2_CLKOUT_OFF }, // DIO5 ClkOut disable for power saving 
....................     /* 0x28 */ { REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN }, // writing to this bit ensures that the FIFO & status flags are reset 
....................     /* 0x29 */ { REG_RSSITHRESH, 220 }, // must be set to dBm = (-Sensitivity / 2), default is 0xE4 = 228 so -114dBm 
....................     /* 0x2D */ { REG_PREAMBLELSB, RF_PREAMBLESIZE_LSB_VALUE }, // default 3 preamble bytes 0xAAAAAA 
....................     /* 0x2E */ { REG_SYNCCONFIG, RF_SYNC_ON | RF_SYNC_FIFOFILL_AUTO | RF_SYNC_SIZE_2 | RF_SYNC_TOL_0 }, 
....................     /* 0x2F */ { REG_SYNCVALUE1, 0x2D },      // attempt to make this compatible with sync1 byte of RFM12B lib 
....................     /* 0x30 */ { REG_SYNCVALUE2, networkID}, // NETWORK ID 
....................     /* 0x37 */ { REG_PACKETCONFIG1, RF_PACKET1_FORMAT_VARIABLE | RF_PACKET1_DCFREE_OFF | RF_PACKET1_CRC_ON | RF_PACKET1_CRCAUTOCLEAR_ON | RF_PACKET1_ADRSFILTERING_OFF }, 
....................     /* 0x38 */ { REG_PAYLOADLENGTH, 66 }, // in variable length mode: the max frame size, not used in TX 
....................     ///* 0x39 */ { REG_NODEADRS, nodeID }, // turned off because we're not using address filtering 
....................     /* 0x3C */ { REG_FIFOTHRESH, RF_FIFOTHRESH_TXSTART_FIFONOTEMPTY | RF_FIFOTHRESH_VALUE }, // TX on FIFO not empty 
....................     /* 0x3D */ { REG_PACKETCONFIG2, RF_PACKET2_RXRESTARTDELAY_2BITS | RF_PACKET2_AUTORXRESTART_ON | RF_PACKET2_AES_OFF }, // RXRESTARTDELAY must match transmitter PA ramp-down time (bitrate dependent) 
....................     //for BR-19200: /* 0x3D */ { REG_PACKETCONFIG2, RF_PACKET2_RXRESTARTDELAY_NONE | RF_PACKET2_AUTORXRESTART_ON | RF_PACKET2_AES_OFF }, // RXRESTARTDELAY must match transmitter PA ramp-down time (bitrate dependent) 
....................     /* 0x6F */ { REG_TESTDAGC, RF_DAGC_IMPROVED_LOWBETA0 }, // run DAGC continuously in RX mode for Fading Margin Improvement, recommended default for AfcLowBetaOn=0 
....................     {255, 0} 
....................   }; 
....................     
....................   // printf("sincronizando"); 
....................   output_high(_slaveSelectPin); 
*
04F2:  BCF    F95.7
04F4:  BSF    F8C.7
....................   int32 start = millis(); 
....................   int timeout = 50; 
04F6:  RCALL  0004
04F8:  MOVFF  03,F8
04FC:  MOVFF  02,F7
0500:  MOVFF  01,F6
0504:  MOVFF  00,F5
0508:  MOVLW  32
050A:  MOVWF  xF9
....................   do writeReg(REG_SYNCVALUE1, 0xAA); while (readReg(REG_SYNCVALUE1) != 0xaa && millis()-start < timeout); 
050C:  MOVLW  2F
050E:  MOVLB  1
0510:  MOVWF  x0F
0512:  MOVLW  AA
0514:  MOVWF  x10
0516:  MOVLB  0
0518:  RCALL  02DE
051A:  MOVLW  2F
051C:  MOVLB  1
051E:  MOVWF  x0D
0520:  MOVLB  0
0522:  RCALL  0332
0524:  MOVF   01,W
0526:  SUBLW  AA
0528:  BZ    055C
052A:  RCALL  0004
052C:  MOVFF  03,FE
0530:  MOVFF  02,FD
0534:  MOVFF  01,FC
0538:  MOVFF  00,FB
053C:  MOVF   xF5,W
053E:  SUBWF  xFB,F
0540:  MOVF   xF6,W
0542:  SUBWFB xFC,F
0544:  MOVF   xF7,W
0546:  SUBWFB xFD,F
0548:  MOVF   xF8,W
054A:  SUBWFB xFE,F
054C:  BNZ   055C
054E:  MOVF   xFD,F
0550:  BNZ   055C
0552:  MOVF   xFC,F
0554:  BNZ   055C
0556:  MOVF   xF9,W
0558:  SUBWF  xFB,W
055A:  BNC   050C
....................   //printf("sincronizado1"); 
....................   start = millis(); 
055C:  RCALL  0004
055E:  MOVFF  03,F8
0562:  MOVFF  02,F7
0566:  MOVFF  01,F6
056A:  MOVFF  00,F5
....................   do writeReg(REG_SYNCVALUE1, 0x55); while (readReg(REG_SYNCVALUE1) != 0x55 && millis()-start < timeout); 
056E:  MOVLW  2F
0570:  MOVLB  1
0572:  MOVWF  x0F
0574:  MOVLW  55
0576:  MOVWF  x10
0578:  MOVLB  0
057A:  RCALL  02DE
057C:  MOVLW  2F
057E:  MOVLB  1
0580:  MOVWF  x0D
0582:  MOVLB  0
0584:  RCALL  0332
0586:  MOVF   01,W
0588:  SUBLW  55
058A:  BZ    05BE
058C:  RCALL  0004
058E:  MOVFF  03,FE
0592:  MOVFF  02,FD
0596:  MOVFF  01,FC
059A:  MOVFF  00,FB
059E:  MOVF   xF5,W
05A0:  SUBWF  xFB,F
05A2:  MOVF   xF6,W
05A4:  SUBWFB xFC,F
05A6:  MOVF   xF7,W
05A8:  SUBWFB xFD,F
05AA:  MOVF   xF8,W
05AC:  SUBWFB xFE,F
05AE:  BNZ   05BE
05B0:  MOVF   xFD,F
05B2:  BNZ   05BE
05B4:  MOVF   xFC,F
05B6:  BNZ   05BE
05B8:  MOVF   xF9,W
05BA:  SUBWF  xFB,W
05BC:  BNC   056E
....................   //printf("sincronizado2"); 
....................    
....................   for (int i = 0; CONFIG[i][0] != 255; i++) 
05BE:  CLRF   xFA
05C0:  BCF    FD8.0
05C2:  RLCF   xFA,W
05C4:  CLRF   xFC
05C6:  MOVWF  xFB
05C8:  MOVFF  FC,03
05CC:  MOVF   xFB,W
05CE:  RCALL  00D2
05D0:  SUBLW  FF
05D2:  BZ    060E
....................     writeReg(CONFIG[i][0], CONFIG[i][1]); 
05D4:  BCF    FD8.0
05D6:  RLCF   xFA,W
05D8:  CLRF   xFC
05DA:  MOVWF  xFB
05DC:  MOVFF  FC,03
05E0:  MOVF   xFB,W
05E2:  RCALL  00D2
05E4:  MOVWF  xFD
05E6:  BCF    FD8.0
05E8:  RLCF   xFA,W
05EA:  CLRF   xFF
05EC:  MOVWF  xFE
05EE:  MOVLW  01
05F0:  ADDWF  xFE,W
05F2:  MOVWF  01
05F4:  MOVLW  00
05F6:  ADDWFC xFF,W
05F8:  MOVWF  03
05FA:  MOVF   01,W
05FC:  RCALL  00D2
05FE:  MOVWF  xFE
0600:  MOVFF  FD,10F
0604:  MOVFF  FE8,110
0608:  RCALL  02DE
060A:  INCF   xFA,F
060C:  BRA    05C0
....................  
....................     
....................   // Encryption is persistent between resets and can trip you up during debugging. 
....................   // Disable it during initialization so we always start from a known state. 
....................    
....................   setHighPower(_isRFM69HW); // called regardless if it's a RFM69W or RFM69HW 
060E:  MOVLW  00
0610:  BTFSC  2A.0
0612:  MOVLW  01
0614:  MOVWF  xFB
0616:  MOVWF  xFC
0618:  RCALL  0354
....................   setMode(RF69_MODE_STANDBY); 
061A:  MOVLW  01
061C:  MOVLB  1
061E:  MOVWF  x0C
0620:  MOVLB  0
0622:  RCALL  03E8
....................   start = millis(); 
0624:  RCALL  0004
0626:  MOVFF  03,F8
062A:  MOVFF  02,F7
062E:  MOVFF  01,F6
0632:  MOVFF  00,F5
....................   while (((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00) && millis()-start < timeout); // wait for ModeReady 
0636:  MOVLW  27
0638:  MOVLB  1
063A:  MOVWF  x0D
063C:  MOVLB  0
063E:  RCALL  0332
0640:  MOVF   01,W
0642:  ANDLW  80
0644:  BNZ   0678
0646:  RCALL  0004
0648:  MOVFF  03,FE
064C:  MOVFF  02,FD
0650:  MOVFF  01,FC
0654:  MOVFF  00,FB
0658:  MOVF   xF5,W
065A:  SUBWF  xFB,F
065C:  MOVF   xF6,W
065E:  SUBWFB xFC,F
0660:  MOVF   xF7,W
0662:  SUBWFB xFD,F
0664:  MOVF   xF8,W
0666:  SUBWFB xFE,F
0668:  BNZ   0678
066A:  MOVF   xFD,F
066C:  BNZ   0678
066E:  MOVF   xFC,F
0670:  BNZ   0678
0672:  MOVF   xF9,W
0674:  SUBWF  xFB,W
0676:  BNC   0636
....................   if (millis()-start >= timeout) 
0678:  RCALL  0004
067A:  MOVFF  03,FE
067E:  MOVFF  02,FD
0682:  MOVFF  01,FC
0686:  MOVFF  00,FB
068A:  MOVF   xF5,W
068C:  SUBWF  xFB,F
068E:  MOVF   xF6,W
0690:  SUBWFB xFC,F
0692:  MOVF   xF7,W
0694:  SUBWFB xFD,F
0696:  MOVF   xF8,W
0698:  SUBWFB xFE,F
069A:  BNZ   06AA
069C:  MOVF   xFD,F
069E:  BNZ   06AA
06A0:  MOVF   xFC,F
06A2:  BNZ   06AA
06A4:  MOVF   xF9,W
06A6:  SUBWF  xFB,W
06A8:  BNC   06B0
....................     return false; 
06AA:  MOVLW  00
06AC:  MOVWF  01
06AE:  BRA    06B8
....................    
....................   //_inISR = false; 
....................     //ext_int_edge(L_TO_H); 
....................    //Enable_interrupts(INT_EXT); 
....................  
....................  //printf("configurado"); 
....................   _address = nodeID; 
06B0:  MOVFF  F4,29
....................   return true; 
06B4:  MOVLW  01
06B6:  MOVWF  01
06B8:  GOTO   0A6C (RETURN)
.................... } 
....................  
....................  
.................... void setMode(int newMode) 
.................... { 
....................    
....................    if (newMode == _mode) 
*
03E8:  MOVF   28,W
03EA:  MOVLB  1
03EC:  SUBWF  x0C,W
03EE:  BNZ   03F2
....................     return; 
03F0:  BRA    04EE
....................  
....................   switch (newMode) { 
03F2:  MOVF   x0C,W
03F4:  XORLW  04
03F6:  MOVLB  0
03F8:  BZ    040C
03FA:  XORLW  07
03FC:  BZ    043C
03FE:  XORLW  01
0400:  BZ    046A
0402:  XORLW  03
0404:  BZ    048C
0406:  XORLW  01
0408:  BZ    04AE
040A:  BRA    04CE
....................     case RF69_MODE_TX: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_TRANSMITTER); 
040C:  MOVLW  01
040E:  MOVLB  1
0410:  MOVWF  x0D
0412:  MOVLB  0
0414:  RCALL  0332
0416:  MOVF   01,W
0418:  ANDLW  E3
041A:  IORLW  0C
041C:  MOVLB  1
041E:  MOVWF  x0D
0420:  MOVLW  01
0422:  MOVWF  x0F
0424:  MOVFF  10D,110
0428:  MOVLB  0
042A:  RCALL  02DE
....................       if (_isRFM69HW) setHighPowerRegs(true); 
042C:  BTFSS  2A.0
042E:  BRA    043A
0430:  MOVLW  01
0432:  MOVLB  1
0434:  MOVWF  x0D
0436:  MOVLB  0
0438:  RCALL  03B2
....................       break; 
043A:  BRA    04D4
....................     case RF69_MODE_RX: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_RECEIVER); 
043C:  MOVLW  01
043E:  MOVLB  1
0440:  MOVWF  x0D
0442:  MOVLB  0
0444:  RCALL  0332
0446:  MOVF   01,W
0448:  ANDLW  E3
044A:  IORLW  10
044C:  MOVLB  1
044E:  MOVWF  x0D
0450:  MOVLW  01
0452:  MOVWF  x0F
0454:  MOVFF  10D,110
0458:  MOVLB  0
045A:  RCALL  02DE
....................       if (_isRFM69HW) setHighPowerRegs(false); 
045C:  BTFSS  2A.0
045E:  BRA    0468
0460:  MOVLB  1
0462:  CLRF   x0D
0464:  MOVLB  0
0466:  RCALL  03B2
....................       break; 
0468:  BRA    04D4
....................     case RF69_MODE_SYNTH: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SYNTHESIZER); 
046A:  MOVLW  01
046C:  MOVLB  1
046E:  MOVWF  x0D
0470:  MOVLB  0
0472:  RCALL  0332
0474:  MOVF   01,W
0476:  ANDLW  E3
0478:  IORLW  08
047A:  MOVLB  1
047C:  MOVWF  x0D
047E:  MOVLW  01
0480:  MOVWF  x0F
0482:  MOVFF  10D,110
0486:  MOVLB  0
0488:  RCALL  02DE
....................       break; 
048A:  BRA    04D4
....................     case RF69_MODE_STANDBY: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_STANDBY); 
048C:  MOVLW  01
048E:  MOVLB  1
0490:  MOVWF  x0D
0492:  MOVLB  0
0494:  RCALL  0332
0496:  MOVF   01,W
0498:  ANDLW  E3
049A:  IORLW  04
049C:  MOVLB  1
049E:  MOVWF  x0D
04A0:  MOVLW  01
04A2:  MOVWF  x0F
04A4:  MOVFF  10D,110
04A8:  MOVLB  0
04AA:  RCALL  02DE
....................       break; 
04AC:  BRA    04D4
....................     case RF69_MODE_SLEEP: 
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SLEEP); 
04AE:  MOVLW  01
04B0:  MOVLB  1
04B2:  MOVWF  x0D
04B4:  MOVLB  0
04B6:  RCALL  0332
04B8:  MOVF   01,W
04BA:  ANDLW  E3
04BC:  MOVLB  1
04BE:  MOVWF  x0D
04C0:  MOVLW  01
04C2:  MOVWF  x0F
04C4:  MOVFF  10D,110
04C8:  MOVLB  0
04CA:  RCALL  02DE
....................       break; 
04CC:  BRA    04D4
....................     default: 
....................       return; 
04CE:  MOVLB  1
04D0:  BRA    04EE
04D2:  MOVLB  0
....................   } 
....................  
....................   // we are using packet mode, so this check is not really needed 
....................   // but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode 
....................   while (_mode == RF69_MODE_SLEEP && (readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady 
04D4:  MOVF   28,F
04D6:  BNZ   04E8
04D8:  MOVLW  27
04DA:  MOVLB  1
04DC:  MOVWF  x0D
04DE:  MOVLB  0
04E0:  RCALL  0332
04E2:  MOVF   01,W
04E4:  ANDLW  80
04E6:  BZ    04D4
....................  
....................   _mode = newMode; 
04E8:  MOVFF  10C,28
04EC:  MOVLB  1
04EE:  MOVLB  0
04F0:  RETURN 0
.................... } 
....................  
.................... short canSend() 
.................... { 
.................... if ((_mode == RF69_MODE_RX) && (PAYLOADLEN == 0) && (readRSSI(1) < CSMA_LIMIT)) // if signal stronger than -100dBm is detected assume channel activity 
*
07B0:  MOVF   28,W
07B2:  SUBLW  03
07B4:  BNZ   07E2
07B6:  MOVF   25,F
07B8:  BNZ   07E2
07BA:  MOVLW  01
07BC:  MOVWF  xFD
07BE:  BRA    0764
07C0:  MOVFF  02,FE
07C4:  MOVFF  01,FD
07C8:  MOVF   xFE,F
07CA:  BNZ   07E2
07CC:  MOVF   24,W
07CE:  SUBWF  xFD,W
07D0:  BC    07E2
....................   { 
....................     setMode(RF69_MODE_STANDBY); 
07D2:  MOVLW  01
07D4:  MOVLB  1
07D6:  MOVWF  x0C
07D8:  MOVLB  0
07DA:  RCALL  03E8
....................     return true; 
07DC:  MOVLW  01
07DE:  MOVWF  01
07E0:  BRA    07E6
....................   } 
....................   return false; 
07E2:  MOVLW  00
07E4:  MOVWF  01
07E6:  GOTO   0956 (RETURN)
.................... } 
....................  
.................... void send(int toAddress, byte * buffer, int bufferSize, short requestACK) 
.................... { 
....................   writeReg(REG_PACKETCONFIG2, (readReg(REG_PACKETCONFIG2) & 0xFB) | RF_PACKET2_RXRESTART); // avoid RX deadlocks 
*
0920:  MOVLW  3D
0922:  MOVLB  1
0924:  MOVWF  x0D
0926:  MOVLB  0
0928:  RCALL  0332
092A:  MOVF   01,W
092C:  ANDLW  FB
092E:  IORLW  04
0930:  MOVWF  xFD
0932:  MOVLW  3D
0934:  MOVLB  1
0936:  MOVWF  x0F
0938:  MOVFF  FD,110
093C:  MOVLB  0
093E:  RCALL  02DE
....................   int32 now = millis(); 
0940:  CALL   0004
0944:  MOVFF  03,FC
0948:  MOVFF  02,FB
094C:  MOVFF  01,FA
0950:  MOVFF  00,F9
....................   while (!canSend() && millis() - now < RF69_CSMA_LIMIT_MS); 
0954:  BRA    07B0
0956:  MOVF   01,F
0958:  BNZ   099C
095A:  CALL   0004
095E:  MOVFF  03,100
0962:  MOVFF  02,FF
0966:  MOVFF  01,FE
096A:  MOVFF  00,FD
096E:  MOVF   xF9,W
0970:  SUBWF  xFD,F
0972:  MOVF   xFA,W
0974:  SUBWFB xFE,F
0976:  MOVF   xFB,W
0978:  SUBWFB xFF,F
097A:  MOVF   xFC,W
097C:  MOVLB  1
097E:  SUBWFB x00,F
0980:  BTFSC  FD8.2
0982:  BRA    0988
0984:  MOVLB  0
0986:  BRA    099C
0988:  MOVLB  0
098A:  MOVF   xFF,F
098C:  BNZ   099C
098E:  MOVF   xFE,W
0990:  SUBLW  03
0992:  BNC   099C
0994:  BNZ   0954
0996:  MOVF   xFD,W
0998:  SUBLW  E7
099A:  BC    0954
....................   sendFrame(toAddress, buffer, bufferSize, requestACK, false); 
099C:  MOVFF  F4,FD
09A0:  MOVFF  F6,FF
09A4:  MOVFF  F5,FE
09A8:  MOVFF  F7,100
09AC:  MOVFF  F8,101
09B0:  MOVLB  1
09B2:  CLRF   x02
09B4:  MOVLB  0
09B6:  BRA    07EA
09B8:  RETURN 0
.................... } 
....................  
.................... // to increase the chance of getting a packet across, call this function instead of send 
.................... // and it handles all the ACK requesting/retrying for you :) 
.................... // The only twist is that you have to manually listen to ACK requests on the other side and send back the ACKs 
.................... // The reason for the semi-automaton is that the lib is interrupt driven and 
.................... // requires user action to read the received data and decide what to do with it 
.................... // replies usually take only 5..8ms at 50kbps@915MHz 
.................... short sendWithRetry(int toAddress, byte *buffer, int bufferSize, int retries, int retryWaitTime) { 
....................   int32 sentTime; 
....................   for (int i = 0; i <= retries; i++) 
....................   { 
....................     send(toAddress, buffer, bufferSize, true); 
....................     sentTime = millis(); 
....................     while (millis() - sentTime < retryWaitTime); 
....................     
....................   } 
....................   return false; 
.................... } 
....................  
....................  
.................... // internal function 
.................... void sendFrame(int toAddress, byte *buffer, int bufferSize, short requestACK, short sendACK) 
.................... { 
....................   setMode(RF69_MODE_STANDBY); // turn off receiver to prevent reception while filling fifo 
*
07EA:  MOVLW  01
07EC:  MOVLB  1
07EE:  MOVWF  x0C
07F0:  MOVLB  0
07F2:  RCALL  03E8
....................   while ((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady 
07F4:  MOVLW  27
07F6:  MOVLB  1
07F8:  MOVWF  x0D
07FA:  MOVLB  0
07FC:  RCALL  0332
07FE:  MOVF   01,W
0800:  ANDLW  80
0802:  BZ    07F4
....................   writeReg(REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_00); // DIO0 is "Packet Sent" 
0804:  MOVLW  25
0806:  MOVLB  1
0808:  MOVWF  x0F
080A:  CLRF   x10
080C:  MOVLB  0
080E:  RCALL  02DE
....................   if (bufferSize > RF69_MAX_DATA_LEN) bufferSize = RF69_MAX_DATA_LEN; 
0810:  MOVLB  1
0812:  MOVF   x00,W
0814:  SUBLW  3D
0816:  BC    081C
0818:  MOVLW  3D
081A:  MOVWF  x00
....................  
....................   // control byte 
....................   byte CTLbyte = 0x00; 
081C:  CLRF   x03
....................   if (sendACK) 
081E:  MOVF   x02,F
0820:  BZ    0828
....................     CTLbyte = RFM69_CTL_SENDACK; 
0822:  MOVLW  80
0824:  MOVWF  x03
0826:  BRA    0830
....................   else if (requestACK) 
0828:  MOVF   x01,F
082A:  BZ    0830
....................     CTLbyte = RFM69_CTL_REQACK; 
082C:  MOVLW  40
082E:  MOVWF  x03
....................  
....................   // write to FIFO 
....................   select(); 
0830:  MOVLB  0
0832:  RCALL  028A
....................   SPItransfer(REG_FIFO | 0x80); 
0834:  MOVLW  80
0836:  MOVLB  1
0838:  MOVWF  x12
083A:  MOVLB  0
083C:  RCALL  0290
....................   SPItransfer(bufferSize + 3); 
083E:  MOVLW  03
0840:  MOVLB  1
0842:  ADDWF  x00,W
0844:  MOVWF  x09
0846:  MOVWF  x12
0848:  MOVLB  0
084A:  RCALL  0290
....................   SPItransfer(toAddress); 
084C:  MOVFF  FD,112
0850:  RCALL  0290
....................   SPItransfer(_address); 
0852:  MOVFF  29,112
0856:  RCALL  0290
....................   SPItransfer(CTLbyte); 
0858:  MOVFF  103,112
085C:  RCALL  0290
....................  
....................   for (int i = 0; i < bufferSize; i++) 
085E:  MOVLB  1
0860:  CLRF   x04
0862:  MOVF   x00,W
0864:  SUBWF  x04,W
0866:  BC    0882
....................     SPItransfer(((byte *) buffer)[i]); 
0868:  MOVF   x04,W
086A:  MOVLB  0
086C:  ADDWF  xFE,W
086E:  MOVWF  FE9
0870:  MOVLW  00
0872:  ADDWFC xFF,W
0874:  MOVWF  FEA
0876:  MOVFF  FEF,112
087A:  RCALL  0290
087C:  MOVLB  1
087E:  INCF   x04,F
0880:  BRA    0862
....................   unselect(); 
0882:  MOVLB  0
0884:  RCALL  02D8
....................  
....................   // no need to wait for transmit mode to be ready since its handled by the radio 
....................   setMode(RF69_MODE_TX); 
0886:  MOVLW  04
0888:  MOVLB  1
088A:  MOVWF  x0C
088C:  MOVLB  0
088E:  RCALL  03E8
....................   int32 txStart = millis(); 
0890:  CALL   0004
0894:  MOVFF  03,108
0898:  MOVFF  02,107
089C:  MOVFF  01,106
08A0:  MOVFF  00,105
....................   while ( input(_interruptPin) == 0 && millis() - txStart < RF69_TX_LIMIT_MS); // wait for DIO0 to turn HIGH signalling transmission finish 
08A4:  BSF    F93.0
08A6:  BTFSC  F81.0
08A8:  BRA    0904
08AA:  CALL   0004
08AE:  MOVFF  03,10D
08B2:  MOVFF  02,10C
08B6:  MOVFF  01,10B
08BA:  MOVFF  00,10A
08BE:  MOVLB  1
08C0:  MOVF   x05,W
08C2:  SUBWF  x0A,F
08C4:  MOVF   x06,W
08C6:  SUBWFB x0B,F
08C8:  MOVF   x07,W
08CA:  SUBWFB x0C,F
08CC:  MOVF   x08,W
08CE:  SUBWFB x0D,F
08D0:  BTFSC  FD8.2
08D2:  BRA    08D8
08D4:  MOVLB  0
08D6:  BRA    0904
08D8:  MOVF   x0C,F
08DA:  BTFSC  FD8.2
08DC:  BRA    08E2
08DE:  MOVLB  0
08E0:  BRA    0904
08E2:  MOVF   x0B,W
08E4:  SUBLW  03
08E6:  BTFSC  FD8.0
08E8:  BRA    08EE
08EA:  MOVLB  0
08EC:  BRA    0904
08EE:  BTFSC  FD8.2
08F0:  BRA    08F6
08F2:  MOVLB  0
08F4:  BRA    08A4
08F6:  MOVF   x0A,W
08F8:  SUBLW  E7
08FA:  BTFSS  FD8.0
08FC:  BRA    0902
08FE:  MOVLB  0
0900:  BRA    08A4
0902:  MOVLB  0
....................   while (readReg(REG_IRQFLAGS2) & (RF_IRQFLAGS2_PACKETSENT == 0x00)); // wait for ModeReady 
0904:  MOVLW  28
0906:  MOVLB  1
0908:  MOVWF  x0D
090A:  MOVLB  0
090C:  RCALL  0332
090E:  ANDLW  00
0910:  BNZ   0904
....................   setMode(RF69_MODE_STANDBY); 
0912:  MOVLW  01
0914:  MOVLB  1
0916:  MOVWF  x0C
0918:  MOVLB  0
091A:  RCALL  03E8
091C:  GOTO   09B8 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... int32 millis() 
.................... { 
....................    return get_ticks(); 
*
0004:  BRA    024A
0006:  RETURN 0
.................... } 
....................  
.................... int readReg(int addr) 
.................... { 
....................   select(); 
*
0332:  RCALL  028A
....................   SPItransfer(addr & 0x7F); 
0334:  MOVLB  1
0336:  MOVF   x0D,W
0338:  ANDLW  7F
033A:  MOVWF  x0F
033C:  MOVWF  x12
033E:  MOVLB  0
0340:  RCALL  0290
....................   int regval = SPIRead8bit(); 
0342:  BRA    02F8
0344:  MOVFF  01,10E
....................   unselect(); 
0348:  RCALL  02D8
....................   return regval; 
034A:  MOVLB  1
034C:  MOVFF  10E,01
0350:  MOVLB  0
0352:  RETURN 0
.................... } 
....................  
.................... void writeReg(int addr, int value) 
.................... { 
....................   select(); 
*
02DE:  RCALL  028A
....................   SPItransfer(addr | 0x80); 
02E0:  MOVLB  1
02E2:  MOVF   x0F,W
02E4:  IORLW  80
02E6:  MOVWF  x11
02E8:  MOVWF  x12
02EA:  MOVLB  0
02EC:  RCALL  0290
....................   SPItransfer(value); 
02EE:  MOVFF  110,112
02F2:  RCALL  0290
....................   unselect(); 
02F4:  RCALL  02D8
02F6:  RETURN 0
.................... } 
....................  
.................... void select() { 
....................   output_low(_slaveSelectPin); 
*
028A:  BCF    F95.7
028C:  BCF    F8C.7
028E:  RETURN 0
.................... } 
....................  
.................... // unselect the RFM69 transceiver (set CS high, restore SPI settings) 
.................... void unselect() { 
....................   output_high(_slaveSelectPin); 
*
02D8:  BCF    F95.7
02DA:  BSF    F8C.7
02DC:  RETURN 0
.................... } 
....................  
....................  
.................... // for RFM69HW only: you must call setHighPower(true) after initialize() or else transmission won't work 
.................... void setHighPower(short onOff) { 
....................   _isRFM69HW = onOff; 
*
0354:  BCF    2A.0
0356:  BTFSC  xFC.0
0358:  BSF    2A.0
....................   writeReg(REG_OCP, _isRFM69HW ? RF_OCP_OFF : RF_OCP_ON); 
035A:  BTFSS  2A.0
035C:  BRA    0362
035E:  MOVLW  0F
0360:  BRA    0364
0362:  MOVLW  1A
0364:  MOVWF  xFD
0366:  MOVLW  13
0368:  MOVLB  1
036A:  MOVWF  x0F
036C:  MOVFF  FD,110
0370:  MOVLB  0
0372:  RCALL  02DE
....................   if (_isRFM69HW) // turning ON 
0374:  BTFSS  2A.0
0376:  BRA    039C
....................     writeReg(REG_PALEVEL, (readReg(REG_PALEVEL) & 0x1F) | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON); // enable P1 & P2 amplifier stages 
0378:  MOVLW  11
037A:  MOVLB  1
037C:  MOVWF  x0D
037E:  MOVLB  0
0380:  RCALL  0332
0382:  MOVF   01,W
0384:  ANDLW  1F
0386:  IORLW  40
0388:  IORLW  20
038A:  MOVWF  xFD
038C:  MOVLW  11
038E:  MOVLB  1
0390:  MOVWF  x0F
0392:  MOVFF  FD,110
0396:  MOVLB  0
0398:  RCALL  02DE
039A:  BRA    03B0
....................   else 
....................     writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | _powerLevel); // enable P0 only 
039C:  MOVF   2B,W
039E:  IORLW  80
03A0:  MOVWF  xFD
03A2:  MOVLW  11
03A4:  MOVLB  1
03A6:  MOVWF  x0F
03A8:  MOVFF  FD,110
03AC:  MOVLB  0
03AE:  RCALL  02DE
03B0:  RETURN 0
....................    //printf("HighPower"); 
.................... } 
....................  
....................  
....................  
.................... /*void readAllRegs() 
.................... { 
....................   int regVal; 
....................   
....................   //... State Variables for intelligent decoding 
....................    
....................   printf("Address - HEX - BIN \n"); 
....................   for (int regAddr = 1; regAddr <= 0x4F; regAddr++) 
....................   { 
....................     select(); 
....................     SPItransfer(regAddr & 0x7F); // send address + r/w bit 
....................     regVal = SPIRead8bit(); 
....................     unselect(); 
....................  
....................     printf("%X", regAddr); 
....................     printf(" - "); 
....................     printf("%X", regVal); 
....................     printf(" - "); 
....................     for (byte i = 8; i!=0 ; i--) 
....................       { 
....................       if(bit_test(regVal, (i-1)))  
....................          printf("1");  
....................       else  
....................          printf("0");  
....................       } 
....................      printf("\n"); 
....................     } 
....................   
....................   unselect(); 
.................... }*/ 
....................  
.................... byte SPItransfer(byte WrPara) 
*
0290:  MOVLB  1
0292:  CLRF   x13
.................... { 
.................... byte Data_In = 0; 
.................... byte bitcnt;    
....................  
.................... Output_Low(SCK); 
0294:  BCF    F95.6
0296:  BCF    F8C.6
....................  for(bitcnt=8; bitcnt!=0; bitcnt--) 
0298:  MOVLW  08
029A:  MOVWF  x14
029C:  MOVF   x14,F
029E:  BZ    02C8
....................     { 
....................     Output_Low(SCK); 
02A0:  BCF    F95.6
02A2:  BCF    F8C.6
....................     if(WrPara&0x80) 
02A4:  BTFSS  x12.7
02A6:  BRA    02AE
....................        Output_High(SerOut);   // RFM69 SDI  
02A8:  BCF    F95.5
02AA:  BSF    F8C.5
02AC:  BRA    02B2
....................     else 
....................        Output_Low(SerOut);    
02AE:  BCF    F95.5
02B0:  BCF    F8C.5
....................     Output_High(SCK); 
02B2:  BCF    F95.6
02B4:  BSF    F8C.6
....................     if (Input(SerIn)) 
02B6:  BSF    F95.4
02B8:  BTFSS  F83.4
02BA:  BRA    02BE
....................       Data_In |= 1; 
02BC:  BSF    x13.0
....................     WrPara <<= 1; 
02BE:  BCF    FD8.0
02C0:  RLCF   x12,F
....................     delay_cycles(1); 
02C2:  NOP   
02C4:  DECF   x14,F
02C6:  BRA    029C
....................     } 
.................... Output_Low(SCK); 
02C8:  BCF    F95.6
02CA:  BCF    F8C.6
.................... Output_High(SerOut); 
02CC:  BCF    F95.5
02CE:  BSF    F8C.5
.................... return(Data_In); 
02D0:  MOVFF  113,01
02D4:  MOVLB  0
02D6:  RETURN 0
.................... } 
....................  
....................  
.................... byte SPIRead8bit(void) 
*
02F8:  MOVLB  1
02FA:  CLRF   x0F
.................... { 
.................... byte RdPara = 0; 
.................... byte bitcnt; 
.................... Output_High(SerOut);   // RFM69 SDI                                                                          //Read one byte data from FIFO, MOSI hold to High  
02FC:  BCF    F95.5
02FE:  BSF    F8C.5
....................  for(bitcnt=8; bitcnt!=0; bitcnt--) 
0300:  MOVLW  08
0302:  MOVWF  x10
0304:  MOVF   x10,F
0306:  BZ    0324
....................     { 
....................     Output_Low(SCK); 
0308:  BCF    F95.6
030A:  BCF    F8C.6
....................     RdPara <<= 1; 
030C:  BCF    FD8.0
030E:  RLCF   x0F,F
....................     Output_High(SCK); 
0310:  BCF    F95.6
0312:  BSF    F8C.6
....................     if(Input(SerIn)) 
0314:  BSF    F95.4
0316:  BTFSS  F83.4
0318:  BRA    031E
....................        RdPara |= 0x01; 
031A:  BSF    x0F.0
031C:  BRA    0320
....................     else 
....................        delay_cycles(1);  
031E:  NOP   
0320:  DECF   x10,F
0322:  BRA    0304
....................     } 
....................  Output_Low(SCK);    
0324:  BCF    F95.6
0326:  BCF    F8C.6
....................  return(RdPara); 
0328:  MOVFF  10F,01
032C:  MOVLB  0
032E:  GOTO   0344 (RETURN)
.................... } 
....................  
.................... int16 readRSSI(short forceTrigger) 
*
0764:  CLRF   xFF
0766:  CLRF   xFE
.................... { 
....................   int16 rssi = 0; 
....................   if (forceTrigger) 
0768:  MOVF   xFD,F
076A:  BZ    078A
....................   { 
....................     // RSSI trigger not needed if DAGC is in continuous mode 
....................     writeReg(REG_RSSICONFIG, RF_RSSI_START); 
076C:  MOVLW  23
076E:  MOVLB  1
0770:  MOVWF  x0F
0772:  MOVLW  01
0774:  MOVWF  x10
0776:  MOVLB  0
0778:  RCALL  02DE
....................     while ((readReg(REG_RSSICONFIG) & RF_RSSI_DONE) == 0x00); // wait for RSSI_Ready 
077A:  MOVLW  23
077C:  MOVLB  1
077E:  MOVWF  x0D
0780:  MOVLB  0
0782:  RCALL  0332
0784:  MOVF   01,W
0786:  ANDLW  02
0788:  BZ    077A
....................   } 
....................   rssi = -readReg(REG_RSSIVALUE); 
078A:  MOVLW  24
078C:  MOVLB  1
078E:  MOVWF  x0D
0790:  MOVLB  0
0792:  RCALL  0332
0794:  COMF   01,W
0796:  MOVWF  xFE
0798:  INCF   xFE,F
079A:  BTFSC  FD8.2
079C:  INCF   xFF,F
....................   rssi >>= 1; 
079E:  BCF    FD8.0
07A0:  RRCF   xFF,F
07A2:  RRCF   xFE,F
....................   return rssi; 
07A4:  MOVFF  FE,01
07A8:  MOVFF  FF,02
07AC:  GOTO   07C0 (RETURN)
.................... } 
....................  
.................... // internal function 
.................... void setHighPowerRegs(short onOff) { 
....................   writeReg(REG_TESTPA1, onOff ? 0x5D : 0x55); 
*
03B2:  MOVLB  1
03B4:  MOVF   x0D,F
03B6:  BZ    03BC
03B8:  MOVLW  5D
03BA:  BRA    03BE
03BC:  MOVLW  55
03BE:  MOVWF  x0E
03C0:  MOVLW  5A
03C2:  MOVWF  x0F
03C4:  MOVFF  10E,110
03C8:  MOVLB  0
03CA:  RCALL  02DE
....................   writeReg(REG_TESTPA2, onOff ? 0x7C : 0x70); 
03CC:  MOVLB  1
03CE:  MOVF   x0D,F
03D0:  BZ    03D6
03D2:  MOVLW  7C
03D4:  BRA    03D8
03D6:  MOVLW  70
03D8:  MOVWF  x0E
03DA:  MOVLW  5C
03DC:  MOVWF  x0F
03DE:  MOVFF  10E,110
03E2:  MOVLB  0
03E4:  RCALL  02DE
03E6:  RETURN 0
.................... } 
....................  
....................  
.................... // ---------------------------------------- 
.................... //Variables--------------- 
.................... //GPS-- 
.................... char GPSData[128]; 
.................... unsigned int8 GPSDataPtr=0;  
.................... char c; 
.................... char cont; 
.................... int  cn; 
.................... int8 GPSDataReady = FALSE;  
.................... int8 GPSmsgCount = 0;  
.................... //RMF69-- 
.................... byte TX_DATA[61]; 
.................... //AUX--- 
.................... //static unsigned int32 Cont = 0; 
.................... //short GPS_Status = 1; 
.................... //int tmr0 = 0; 
....................  
.................... //-------------------------------------- 
.................... //Funciones 
....................  
.................... void GPS_Pack() 
.................... { 
....................    for(int i=0; i<61; i++) 
*
06E2:  CLRF   xF4
06E4:  MOVF   xF4,W
06E6:  SUBLW  3C
06E8:  BNC   071E
....................    { 
....................       GPSData[i]=GPSData[i+7]; 
06EA:  CLRF   03
06EC:  MOVF   xF4,W
06EE:  ADDLW  2C
06F0:  MOVWF  01
06F2:  MOVLW  00
06F4:  ADDWFC 03,F
06F6:  MOVFF  03,F6
06FA:  MOVLW  07
06FC:  ADDWF  xF4,W
06FE:  CLRF   03
0700:  ADDLW  2C
0702:  MOVWF  FE9
0704:  MOVLW  00
0706:  ADDWFC 03,W
0708:  MOVWF  FEA
070A:  MOVFF  FEF,F7
070E:  MOVFF  F6,FEA
0712:  MOVFF  01,FE9
0716:  MOVFF  F7,FEF
071A:  INCF   xF4,F
071C:  BRA    06E4
....................    } 
071E:  GOTO   0ACC (RETURN)
.................... } 
....................  
....................  
.................... #define INTS_PER_SECOND 1//0       // 10 = 21sec;  
....................  
.................... int8 seconds;      // A running seconds counter 
.................... int8 int_count;    // Number of interrupts left before a second has elapsed 
....................  
....................  
.................... #INT_TIMER2                        // This function is called every time 
.................... void clock_isr() {                 // timer 2 overflows (250->0), which is 
....................                                    // approximately 125 times per second for 
....................     if(--int_count==0) {           // this program. 
*
012C:  DECF   xF0,F
012E:  MOVF   xF0,F
0130:  BNZ   0144
....................       if(++seconds==21) 
0132:  INCF   xEF,F
0134:  MOVF   xEF,W
0136:  SUBLW  15
0138:  BNZ   0140
....................       { 
....................          seconds = 0; 
013A:  CLRF   xEF
....................          Output_high(GPSPower); 
013C:  BCF    F95.2
013E:  BSF    F8C.2
....................       } 
....................       int_count = INTS_PER_SECOND; 
0140:  MOVLW  01
0142:  MOVWF  xF0
....................     } 
.................... } 
....................  
.................... //------------------------ 
.................... //INT Lectura del UART GPS 
0144:  BCF    F9E.1
0146:  GOTO   0084
.................... #INT_RDA 
.................... void RDA_isr(void)  
.................... {  
....................    c = getc();  
*
01AE:  BRA    014A
01B0:  MOVFF  01,AD
....................    switch (c)  
01B4:  MOVF   xAD,W
01B6:  XORLW  24
01B8:  BZ    01C0
01BA:  XORLW  2E
01BC:  BZ    01C4
01BE:  BRA    0208
....................    {  
....................       case '$':  
....................          GPSDataPtr = 0;  
01C0:  CLRF   xAC
....................       break;  
01C2:  BRA    0208
....................        
....................       case '\n':  
....................          GPSmsgCount++; 
01C4:  INCF   xB1,F
....................            if ( (StrFnd(GPSData, 'A', 0) == 17) && (GPSData[0]=='$') && (GPSData[1]== 'G') && (GPSData[2]== 'P') 
....................          && (GPSData[3]== 'R')&& (GPSData[4]== 'M') && (GPSData[5]== 'C')) 
01C6:  MOVLB  1
01C8:  CLRF   x16
01CA:  MOVLW  2C
01CC:  MOVWF  x15
01CE:  MOVLW  41
01D0:  MOVWF  x17
01D2:  CLRF   x19
01D4:  CLRF   x18
01D6:  MOVLB  0
01D8:  BRA    0162
01DA:  MOVF   01,W
01DC:  SUBLW  11
01DE:  BNZ   0208
01E0:  MOVF   2C,W
01E2:  SUBLW  24
01E4:  BNZ   0208
01E6:  MOVF   2D,W
01E8:  SUBLW  47
01EA:  BNZ   0208
01EC:  MOVF   2E,W
01EE:  SUBLW  50
01F0:  BNZ   0208
01F2:  MOVF   2F,W
01F4:  SUBLW  52
01F6:  BNZ   0208
01F8:  MOVF   30,W
01FA:  SUBLW  4D
01FC:  BNZ   0208
01FE:  MOVF   31,W
0200:  SUBLW  43
0202:  BNZ   0208
....................          { 
....................             GPSDataReady = TRUE; 
0204:  MOVLW  01
0206:  MOVWF  xB0
....................          } 
....................       break;  
....................    }  
....................      
....................    GPSData[GPSDataPtr++ & 0x7F] = c;  
0208:  MOVF   xAC,W
020A:  INCF   xAC,F
020C:  ANDLW  7F
020E:  CLRF   03
0210:  ADDLW  2C
0212:  MOVWF  FE9
0214:  MOVLW  00
0216:  ADDWFC 03,W
0218:  MOVWF  FEA
021A:  MOVFF  AD,FEF
.................... }  
....................  
021E:  BCF    F9E.5
0220:  GOTO   0084
.................... #INT_EXT2 
.................... void EXT2_isr(void) 
.................... { 
....................    if(cn == 0){ 
0224:  MOVF   xAF,F
0226:  BNZ   0230
....................    cn = 1; 
0228:  MOVLW  01
022A:  MOVWF  xAF
....................    cont = '2';} 
022C:  MOVLW  32
022E:  MOVWF  xAE
0230:  BCF    FF0.1
0232:  GOTO   0084
.................... } 
....................  
.................... void main(void) 
*
09DC:  CLRF   FF8
09DE:  BCF    FD0.7
09E0:  BSF    07.7
09E2:  MOVLW  FE
09E4:  MOVWF  00
09E6:  MOVLW  08
09E8:  MOVWF  01
09EA:  MOVLW  02
09EC:  MOVWF  FE9
09EE:  MOVLW  00
09F0:  MOVWF  FEA
09F2:  CLRF   FEE
09F4:  DECFSZ 00,F
09F6:  BRA    09F2
09F8:  DECFSZ 01,F
09FA:  BRA    09F2
09FC:  CLRF   1F
09FE:  BSF    FB8.3
0A00:  MOVLW  08
0A02:  MOVWF  FAF
0A04:  MOVLW  02
0A06:  MOVWF  FB0
0A08:  MOVLW  A6
0A0A:  MOVWF  FAC
0A0C:  MOVLW  90
0A0E:  MOVWF  FAB
0A10:  CLRF   23
0A12:  CLRF   22
0A14:  CLRF   21
0A16:  CLRF   20
0A18:  MOVLW  B5
0A1A:  MOVWF  FCD
0A1C:  CLRF   FCF
0A1E:  CLRF   FCE
0A20:  BCF    F9E.0
0A22:  BSF    F9D.0
0A24:  MOVLW  A6
0A26:  MOVWF  24
0A28:  BSF    2A.0
0A2A:  MOVLW  1F
0A2C:  MOVWF  2B
0A2E:  CLRF   xAC
0A30:  CLRF   xB0
0A32:  CLRF   xB1
0A34:  CLRF   xF2
0A36:  CLRF   xF1
0A38:  MOVF   FC1,W
0A3A:  ANDLW  C0
0A3C:  IORLW  0F
0A3E:  MOVWF  FC1
0A40:  MOVLW  07
0A42:  MOVWF  FB4
0A44:  CLRF   19
0A46:  CLRF   1A
0A48:  CLRF   25
0A4A:  CLRF   26
0A4C:  CLRF   27
0A4E:  CLRF   28
0A50:  CLRF   29
.................... {  
.................... #zero_ram 
....................  
.................... set_tris_b(0b00000111);     //DIO0 
0A52:  MOVLW  07
0A54:  MOVWF  F93
.................... set_tris_C(0b10000000);     // ser in 0 
0A56:  MOVLW  80
0A58:  MOVWF  F94
.................... set_tris_D(0b00010000); 
0A5A:  MOVLW  10
0A5C:  MOVWF  F95
....................  
.................... //-------------------------------------- 
.................... //Config RFM69-------------------------- 
....................    Output_High(_slaveSelectPin); 
0A5E:  BCF    F95.7
0A60:  BSF    F8C.7
....................    Output_Low(SCK); 
0A62:  BCF    F95.6
0A64:  BCF    F8C.6
....................    initialize(2); 
0A66:  MOVLW  02
0A68:  MOVWF  xF4
0A6A:  BRA    04F2
....................    delay_ms(500); 
0A6C:  MOVLW  02
0A6E:  MOVWF  xF4
0A70:  MOVLW  FA
0A72:  MOVWF  xF5
0A74:  RCALL  06BC
0A76:  DECFSZ xF4,F
0A78:  BRA    0A70
....................    setHighPower(1); 
0A7A:  MOVLW  01
0A7C:  MOVWF  xFC
0A7E:  RCALL  0354
....................    //readAllRegs(); 
.................... //-------------------------------------- 
.................... //Config GPS 
....................    //GPRMCInfo MyGPRMCInfo; 
.................... //-------------------------------------- 
....................    //setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit); //86ms ~ RTCC_DIV_256|RTCC_8_bit 
....................   // set_timer0(tmr0);                                     //86ms ~ tmr0=0; 
....................   
.................... //1seg ~> cont = 12; 1min ~> cont = 700  
.................... //------------------------------------------------------------  
....................    int_count = INTS_PER_SECOND; 
0A80:  MOVLW  01
0A82:  MOVWF  xF0
....................    setup_timer_2(T2_DIV_BY_16, 250, 10); 
0A84:  MOVLW  48
0A86:  IORLW  06
0A88:  MOVWF  FCA
0A8A:  MOVLW  FA
0A8C:  MOVWF  FCB
....................    set_timer2(0); 
0A8E:  CLRF   FCC
....................    enable_interrupts(INT_TIMER2); 
0A90:  BSF    F9D.1
....................    int_count = INTS_PER_SECOND; 
0A92:  MOVLW  01
0A94:  MOVWF  xF0
....................     
....................    cn = 0; 
0A96:  CLRF   xAF
....................    Output_high(GPSPower); 
0A98:  BCF    F95.2
0A9A:  BSF    F8C.2
....................    ext_int_edge(2,L_TO_H); 
0A9C:  BSF    FF1.4
....................    enable_interrupts(INT_RDA); 
0A9E:  BSF    F9D.5
....................    enable_interrupts(INT_EXT2); 
0AA0:  BSF    FF0.4
....................    enable_interrupts(GLOBAL); 
0AA2:  MOVLW  C0
0AA4:  IORWF  FF2,F
....................     
....................  
.................... // -------------------------------------------------------------- 
.................... while(true) 
....................    { 
....................       for(int i=0;i<61;i++) 
0AA6:  CLRF   xF3
0AA8:  MOVF   xF3,W
0AAA:  SUBLW  3C
0AAC:  BNC   0AC2
....................       { 
....................          sprintf(TX_DATA,"\0"); 
0AAE:  CLRF   xF2
0AB0:  MOVLW  B2
0AB2:  MOVWF  xF1
0AB4:  MOVFF  F2,FEA
0AB8:  MOVFF  F1,FE9
0ABC:  CLRF   FEF
0ABE:  INCF   xF3,F
0AC0:  BRA    0AA8
....................       } 
....................       while(cn == 0){ 
0AC2:  MOVF   xAF,F
0AC4:  BNZ   0B04
....................       if (GPSDataReady) 
0AC6:  MOVF   xB0,F
0AC8:  BZ    0B02
....................       {  
....................          //GPRMC_decode(GPSData, &MyGPRMCInfo); 
....................          //if (MyGPRMCInfo.Valid == 'A')  
....................          //{  
....................             GPS_Pack(); 
0ACA:  BRA    06E2
....................             sprintf(TX_DATA, "%s", GPSData); 
0ACC:  CLRF   xF2
0ACE:  MOVLW  B2
0AD0:  MOVWF  xF1
0AD2:  MOVFF  F2,FEA
0AD6:  MOVFF  F1,FE9
0ADA:  CLRF   FEF
0ADC:  CLRF   FEA
0ADE:  MOVLW  2C
0AE0:  MOVWF  FE9
0AE2:  BRA    073E
....................            // for (int i = 0; i < 2; i ++) 
....................             //{ 
....................                send(0x01, TX_DATA, 61, 0); 
0AE4:  MOVLW  01
0AE6:  MOVWF  xF4
0AE8:  CLRF   xF6
0AEA:  MOVLW  B2
0AEC:  MOVWF  xF5
0AEE:  MOVLW  3D
0AF0:  MOVWF  xF7
0AF2:  CLRF   xF8
0AF4:  RCALL  0920
....................                delay_ms(100); 
0AF6:  MOVLW  64
0AF8:  MOVWF  xF5
0AFA:  RCALL  06BC
....................             //} 
....................              
....................          //} 
....................          Output_low(GPSPower); 
0AFC:  BCF    F95.2
0AFE:  BCF    F8C.2
....................          //delay_ms(20000); 
....................          //Output_high(GPSPower); 
....................          GPSDataReady = FALSE;  
0B00:  CLRF   xB0
....................       }   
0B02:  BRA    0AC2
....................         
....................       } 
....................     
....................        sprintf(TX_DATA, "ERROR,desconectado"); 
0B04:  CLRF   xF2
0B06:  MOVLW  B2
0B08:  MOVWF  xF1
0B0A:  MOVLW  36
0B0C:  MOVWF  FF6
0B0E:  MOVLW  02
0B10:  MOVWF  FF7
0B12:  BRA    09BA
....................        send(0x01, TX_DATA, 61, 0); 
0B14:  MOVLW  01
0B16:  MOVWF  xF4
0B18:  CLRF   xF6
0B1A:  MOVLW  B2
0B1C:  MOVWF  xF5
0B1E:  MOVLW  3D
0B20:  MOVWF  xF7
0B22:  CLRF   xF8
0B24:  RCALL  0920
....................        delay_ms(100); 
0B26:  MOVLW  64
0B28:  MOVWF  xF5
0B2A:  RCALL  06BC
....................        if (input(PIN_B1) == 1) 
0B2C:  BSF    F93.1
0B2E:  BTFSS  F81.1
0B30:  BRA    0B34
....................        { 
....................          cn = 0; 
0B32:  CLRF   xAF
....................        } 
0B34:  BRA    0AA6
....................   } 
....................    // End While Loop 
.................... }         // End Main  
....................  
0B36:  SLEEP 
....................  
.................... /*****************************************************************************/ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: CC04   PLL5 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV21 NOVREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
